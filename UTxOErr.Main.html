<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>UTxOErr.Main</title><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css'/><style>.github-fork-ribbon:before { background-color: #333; }</style><link rel="stylesheet" href="css/Agda.css"></head><body><a class='github-fork-ribbon'href='https://github.com/omelkonian/hoare-ledgers/tree/master/UTxOErr/Main.agda'data-ribbon='Source code on Github' title='Source code on Github'>Source code on Github</a><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--rewriting</a> <a id="25" class="Symbol">#-}</a>
<a id="29" class="Keyword">module</a> <a id="36" href="UTxOErr.Main.html" class="Module">UTxOErr.Main</a> <a id="49" class="Keyword">where</a>

<a id="56" class="Comment">-- ** Maps as `K → Maybe V`.</a>
<a id="85" class="Keyword">open</a> <a id="90" class="Keyword">import</a> <a id="97" href="UTxOErr.Maps.html" class="Module">UTxOErr.Maps</a>

<a id="111" class="Comment">-- ** Simplistic definition of the UTxO model.</a>
<a id="158" class="Comment">-- S := Map⟨ TxOutputRef ↦ TxOutput ⟩</a>
<a id="196" class="Keyword">open</a> <a id="201" class="Keyword">import</a> <a id="208" href="UTxOErr.UTxO.html" class="Module">UTxOErr.UTxO</a>

<a id="222" class="Comment">-- ** A simple definition of a bank ledger as a series of transactions: A —→⟨ v ⟩ B.</a>
<a id="307" class="Comment">-- We model the ledger state as maps from participants to balances, using a concrete map implementation in ValueSep.Maps,</a>
<a id="429" class="Comment">-- and define both operational and denotational semantics.</a>
<a id="488" class="Comment">-- [Proofs]</a>
<a id="500" class="Comment">--    * correspondence between operational and denotational semantics</a>
<a id="570" class="Comment">--    * useful lemmas about the ledger-specific operation `transfer/[_∣_↦_]`</a>
<a id="647" class="Keyword">open</a> <a id="652" class="Keyword">import</a> <a id="659" href="UTxOErr.Ledger.html" class="Module">UTxOErr.Ledger</a>

<a id="675" class="Comment">-- ** A Hoare-style axiomatic semantics, based on a deep embedding of propositions.</a>
<a id="759" class="Comment">-- We also provide some utilities for working with Hoare triples and convenient reasoning syntax.</a>
<a id="857" class="Comment">-- [Proofs]</a>
<a id="869" class="Comment">--   * correspondence with denotational semantics and, by transitivity, operational semantics.</a>
<a id="964" class="Comment">--   * associativity/commutativity of separating conjuction _∗_</a>
<a id="1028" class="Keyword">open</a> <a id="1033" class="Keyword">import</a> <a id="1040" href="UTxOErr.HoareLogic.html" class="Module">UTxOErr.HoareLogic</a>
<a id="1059" class="Keyword">open</a> <a id="1064" class="Keyword">import</a> <a id="1071" href="UTxOErr.HoareProperties.html" class="Module">UTxOErr.HoareProperties</a>

<a id="1096" class="Comment">-- ** Introduce the concept of disjointness for propositions, i.e. when the participants they refer to do not overlap,</a>
<a id="1215" class="Comment">-- which allows us to express the frame rule of Separation Logic (SL).</a>
<a id="1286" class="Comment">-- [Proofs]</a>
<a id="1298" class="Comment">--  * useful lemmas about separation, transferring values, etc...</a>
<a id="1364" class="Comment">--  * the [FRAME] inference rule, which allows us to reason about a sub-formula and then inject the result in a larger context</a>
<a id="1491" class="Keyword">open</a> <a id="1496" class="Keyword">import</a> <a id="1503" href="UTxOErr.SL.html" class="Module">UTxOErr.SL</a>

<a id="1515" class="Comment">-- **ISSUE** How do we formulate frame, seems incompatible with the semantics of a transaction that fails.</a>
<a id="1622" class="Comment">-- **SOLUTION** Change domain to incorporate failure, i.e. `S -&gt; S` to `S -&gt; Maybe S`.</a>

<a id="1710" class="Comment">-- ** Define interleaving of two ledgers and prove the parallel rule of Concurrent Separation Logic (CSL).</a>
<a id="1817" class="Comment">-- [Proofs]</a>
<a id="1829" class="Comment">--  * the [PAR] inference rule, which utilizes [FRAME] to let us reason about disjoint ledgers independently/concurrently,</a>
<a id="1952" class="Comment">-- and then compose the proofs (given that the pre-/post-conditions are sufficiently disjoint)</a>
<a id="2047" class="Comment">-- to conclude something of a larger ledgers, namely any ledger that is an interleaving of the first two.</a>
<a id="2153" class="Keyword">open</a> <a id="2158" class="Keyword">import</a> <a id="2165" href="UTxOErr.CSL.html" class="Module">UTxOErr.CSL</a>

<a id="2178" class="Comment">-- ** An example of a ledger consisting of 4 transactions t₁⋯t₄,</a>
<a id="2243" class="Comment">--    recording that values are correctly updated in pre-/post-conditions.</a>
<a id="2318" class="Comment">-- 1. the first proof h repeatively uses the [FRAME] rule,</a>
<a id="2377" class="Comment">--    but it quickly gets tedious because we need to reason about the whole ledger (all 4 transactions),</a>
<a id="2482" class="Comment">--    although t₁ and t₃ act on a completely different set of participants than t₂ and t₄.</a>
<a id="2573" class="Comment">-- 2. the second proof h′ utilizes modular reasoning via [PAR];</a>
<a id="2637" class="Comment">--    we only prove smaller/simpler proofs for t₁/t₃ and t₂/t₄ and then compose them.</a>
<a id="2723" class="Keyword">open</a> <a id="2728" class="Keyword">import</a> <a id="2735" href="UTxOErr.Example.html" class="Module">UTxOErr.Example</a>
</pre></body></html>