<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>UTxO.SL</title><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css'/><style>.github-fork-ribbon:before { background-color: #333; }</style><link rel="stylesheet" href="css/Agda.css"></head><body><a class='github-fork-ribbon'href='https://github.com/omelkonian/hoare-ledgers/tree/master///UTxO/SL.agda'data-ribbon='Source code on Github' title='Source code on Github'>Source code on Github</a><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--allow-unsolved-metas</a> <a id="36" class="Symbol">#-}</a>
<a id="40" class="Comment">---------------------------</a>
<a id="68" class="Comment">-- ** Separation logic (SL)</a>

<a id="97" class="Keyword">module</a> <a id="104" href="UTxO.SL.html" class="Module">UTxO.SL</a> <a id="112" class="Keyword">where</a>

<a id="119" class="Keyword">open</a> <a id="124" class="Keyword">import</a> <a id="131" href="Prelude.Init.html" class="Module">Prelude.Init</a><a id="143" class="Symbol">;</a> <a id="145" class="Keyword">open</a> <a id="150" href="Prelude.Init.html#504" class="Module">SetAsType</a>
<a id="160" class="Keyword">open</a> <a id="165" href="Prelude.Init.html#7254" class="Module">L.Mem</a>
<a id="171" class="Keyword">open</a> <a id="176" class="Keyword">import</a> <a id="183" href="Prelude.DecEq.html" class="Module">Prelude.DecEq</a>
<a id="197" class="Keyword">open</a> <a id="202" class="Keyword">import</a> <a id="209" href="Prelude.Decidable.html" class="Module">Prelude.Decidable</a>
<a id="227" class="Keyword">open</a> <a id="232" class="Keyword">import</a> <a id="239" href="Prelude.Sets.html" class="Module">Prelude.Sets</a>
<a id="252" class="Keyword">open</a> <a id="257" class="Keyword">import</a> <a id="264" href="Prelude.Ord.html" class="Module">Prelude.Ord</a>
<a id="276" class="Keyword">open</a> <a id="281" class="Keyword">import</a> <a id="288" href="Prelude.Functor.html" class="Module">Prelude.Functor</a>
<a id="304" class="Keyword">open</a> <a id="309" class="Keyword">import</a> <a id="316" href="Prelude.Apartness.html" class="Module">Prelude.Apartness</a>

<a id="335" class="Keyword">open</a> <a id="340" class="Keyword">import</a> <a id="347" href="UTxO.UTxO.html" class="Module">UTxO.UTxO</a>
<a id="357" class="Keyword">open</a> <a id="362" class="Keyword">import</a> <a id="369" href="UTxO.Ledger.html" class="Module">UTxO.Ledger</a>
<a id="381" class="Keyword">open</a> <a id="386" class="Keyword">import</a> <a id="393" href="UTxO.HoareLogic.html" class="Module">UTxO.HoareLogic</a>

<a id="410" class="Comment">-- Which addresses does a ledger modify?</a>
<a id="mod"></a><a id="451" href="UTxO.SL.html#451" class="Function">mod</a> <a id="455" class="Symbol">:</a> <a id="457" href="UTxO.UTxO.html#463" class="Function">Address</a> <a id="465" class="Symbol">→</a> <a id="467" href="UTxO.UTxO.html#1819" class="Function">L</a> <a id="469" class="Symbol">→</a> <a id="471" href="Agda.Primitive.html#320" class="Primitive">Type</a>
<a id="476" href="UTxO.SL.html#451" class="Function">mod</a> <a id="480" href="UTxO.SL.html#480" class="Bound">A</a> <a id="482" class="Symbol">=</a> <a id="484" href="Data.List.Relation.Unary.Any.html#1165" class="Datatype">Any</a> <a id="488" class="Symbol">λ</a> <a id="490" href="UTxO.SL.html#490" class="Bound">tx</a> <a id="493" class="Symbol">→</a> <a id="495" href="UTxO.SL.html#480" class="Bound">A</a> <a id="497" href="Data.List.Membership.Setoid.html#896" class="Function Operator">∈</a> <a id="499" class="Symbol">(</a><a id="500" href="UTxO.UTxO.html#856" class="Field">address</a> <a id="508" href="Prelude.Functor.html#382" class="Field Operator">&lt;$&gt;</a> <a id="512" href="UTxO.SL.html#490" class="Bound">tx</a> <a id="515" class="Symbol">.</a><a id="516" href="UTxO.UTxO.html#1582" class="Field">outputs</a><a id="523" class="Symbol">)</a>

<a id="526" class="Comment">-- Which addresses does an assertion refer to?</a>
<a id="addr"></a><a id="573" href="UTxO.SL.html#573" class="Function">addr</a> <a id="578" class="Symbol">:</a> <a id="580" href="UTxO.UTxO.html#463" class="Function">Address</a> <a id="588" class="Symbol">→</a> <a id="590" href="UTxO.HoareLogic.html#515" class="Datatype">Assertion</a> <a id="600" class="Symbol">→</a> <a id="602" href="Agda.Primitive.html#320" class="Primitive">Type</a>
<a id="607" href="UTxO.SL.html#573" class="Function">addr</a> <a id="612" href="UTxO.SL.html#612" class="Bound">A</a> <a id="614" href="UTxO.HoareLogic.html#541" class="InductiveConstructor">`emp</a>     <a id="623" class="Symbol">=</a> <a id="625" href="Data.Empty.html#535" class="Datatype">⊥</a>
<a id="627" href="UTxO.SL.html#573" class="Function">addr</a> <a id="632" href="UTxO.SL.html#632" class="Bound">A</a> <a id="634" class="Symbol">(</a><a id="635" href="UTxO.SL.html#635" class="Bound">B</a> <a id="637" href="UTxO.HoareLogic.html#617" class="InductiveConstructor Operator">`↦</a> <a id="640" class="Symbol">_)</a> <a id="643" class="Symbol">=</a> <a id="645" href="UTxO.SL.html#632" class="Bound">A</a> <a id="647" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="649" href="UTxO.SL.html#635" class="Bound">B</a>
<a id="651" href="UTxO.SL.html#573" class="Function">addr</a> <a id="656" href="UTxO.SL.html#656" class="Bound">A</a> <a id="658" class="Symbol">(</a><a id="659" href="UTxO.SL.html#659" class="Bound">P</a> <a id="661" href="UTxO.HoareLogic.html#705" class="InductiveConstructor Operator">`∗</a> <a id="664" href="UTxO.SL.html#664" class="Bound">Q</a><a id="665" class="Symbol">)</a> <a id="667" class="Symbol">=</a> <a id="669" href="UTxO.SL.html#573" class="Function">addr</a> <a id="674" href="UTxO.SL.html#656" class="Bound">A</a> <a id="676" href="UTxO.SL.html#659" class="Bound">P</a> <a id="678" href="Data.Sum.Base.html#743" class="Datatype Operator">⊎</a> <a id="680" href="UTxO.SL.html#573" class="Function">addr</a> <a id="685" href="UTxO.SL.html#656" class="Bound">A</a> <a id="687" href="UTxO.SL.html#664" class="Bound">Q</a>
<a id="689" href="UTxO.SL.html#573" class="Function">addr</a> <a id="694" href="UTxO.SL.html#694" class="Bound">A</a> <a id="696" class="Symbol">(</a><a id="697" href="UTxO.SL.html#697" class="Bound">P</a> <a id="699" href="UTxO.HoareLogic.html#776" class="InductiveConstructor Operator">`∘⟦</a> <a id="703" class="Symbol">_</a> <a id="705" href="UTxO.HoareLogic.html#776" class="InductiveConstructor Operator">⟧</a><a id="706" class="Symbol">)</a> <a id="708" class="Symbol">=</a> <a id="710" href="UTxO.SL.html#573" class="Function">addr</a> <a id="715" href="UTxO.SL.html#694" class="Bound">A</a> <a id="717" href="UTxO.SL.html#697" class="Bound">P</a>

<a id="720" class="Comment">-- Define disjointness between ledgers/states/formulas as disjointness of the participant set they refer to.</a>
<a id="829" class="Keyword">instance</a>
  <a id="Disjoint-LS"></a><a id="840" href="UTxO.SL.html#840" class="Function">Disjoint-LS</a> <a id="852" class="Symbol">:</a> <a id="854" href="UTxO.UTxO.html#1819" class="Function">L</a> <a id="856" href="Prelude.Apartness.html#162" class="Record Operator">//</a> <a id="859" href="UTxO.UTxO.html#2052" class="Function">S</a>
  <a id="863" href="UTxO.SL.html#840" class="Function">Disjoint-LS</a> <a id="875" class="Symbol">.</a><a id="876" href="Prelude.Apartness.html#255" class="Field Operator">_♯_</a> <a id="880" href="UTxO.SL.html#880" class="Bound">l</a> <a id="882" href="UTxO.SL.html#882" class="Bound">s</a> <a id="884" class="Symbol">=</a> <a id="886" class="Symbol">∀</a> <a id="888" href="UTxO.SL.html#888" class="Bound">A</a> <a id="890" class="Symbol">→</a> <a id="892" href="UTxO.SL.html#451" class="Function">mod</a> <a id="896" href="UTxO.SL.html#888" class="Bound">A</a> <a id="898" href="UTxO.SL.html#880" class="Bound">l</a> <a id="900" class="Symbol">→</a> <a id="902" href="Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="904" href="Data.Product.html#1378" class="Function">∃</a> <a id="906" class="Symbol">λ</a> <a id="908" href="UTxO.SL.html#908" class="Bound">utxo</a> <a id="913" class="Symbol">→</a> <a id="915" class="Symbol">(</a><a id="916" href="UTxO.SL.html#908" class="Bound">utxo</a> <a id="921" class="Symbol">.</a><a id="922" href="UTxO.UTxO.html#1894" class="Field">UTXO.out</a> <a id="931" class="Symbol">.</a><a id="932" href="UTxO.UTxO.html#856" class="Field">address</a> <a id="940" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="942" href="UTxO.SL.html#888" class="Bound">A</a><a id="943" class="Symbol">)</a> <a id="945" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="947" class="Symbol">(</a><a id="948" href="UTxO.SL.html#908" class="Bound">utxo</a> <a id="953" href="Prelude.Sets.AsUniqueLists.Core.html#2212" class="Function Operator">∈ˢ</a> <a id="956" href="UTxO.SL.html#882" class="Bound">s</a><a id="957" class="Symbol">)</a>

  <a id="Disjoint-SL"></a><a id="962" href="UTxO.SL.html#962" class="Function">Disjoint-SL</a> <a id="974" class="Symbol">:</a> <a id="976" href="UTxO.UTxO.html#2052" class="Function">S</a> <a id="978" href="Prelude.Apartness.html#162" class="Record Operator">//</a> <a id="981" href="UTxO.UTxO.html#1819" class="Function">L</a>
  <a id="985" href="UTxO.SL.html#962" class="Function">Disjoint-SL</a> <a id="997" class="Symbol">.</a><a id="998" href="Prelude.Apartness.html#255" class="Field Operator">_♯_</a> <a id="1002" href="UTxO.SL.html#1002" class="Bound">s</a> <a id="1004" href="UTxO.SL.html#1004" class="Bound">l</a> <a id="1006" class="Symbol">=</a> <a id="1008" class="Symbol">∀</a> <a id="1010" href="UTxO.SL.html#1010" class="Bound">A</a> <a id="1012" class="Symbol">→</a> <a id="1014" class="Symbol">(</a><a id="1015" href="Data.Product.html#1378" class="Function">∃</a> <a id="1017" class="Symbol">λ</a> <a id="1019" href="UTxO.SL.html#1019" class="Bound">utxo</a> <a id="1024" class="Symbol">→</a> <a id="1026" class="Symbol">(</a><a id="1027" href="UTxO.SL.html#1019" class="Bound">utxo</a> <a id="1032" class="Symbol">.</a><a id="1033" href="UTxO.UTxO.html#1894" class="Field">UTXO.out</a> <a id="1042" class="Symbol">.</a><a id="1043" href="UTxO.UTxO.html#856" class="Field">address</a> <a id="1051" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="1053" href="UTxO.SL.html#1010" class="Bound">A</a><a id="1054" class="Symbol">)</a> <a id="1056" href="Data.Product.html#1176" class="Function Operator">×</a> <a id="1058" class="Symbol">(</a><a id="1059" href="UTxO.SL.html#1019" class="Bound">utxo</a> <a id="1064" href="Prelude.Sets.AsUniqueLists.Core.html#2212" class="Function Operator">∈ˢ</a> <a id="1067" href="UTxO.SL.html#1002" class="Bound">s</a><a id="1068" class="Symbol">))</a> <a id="1071" class="Symbol">→</a> <a id="1073" href="Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="1075" href="UTxO.SL.html#451" class="Function">mod</a> <a id="1079" href="UTxO.SL.html#1010" class="Bound">A</a> <a id="1081" href="UTxO.SL.html#1004" class="Bound">l</a>

  <a id="Disjoint-LA"></a><a id="1086" href="UTxO.SL.html#1086" class="Function">Disjoint-LA</a> <a id="1098" class="Symbol">:</a> <a id="1100" href="UTxO.UTxO.html#1819" class="Function">L</a> <a id="1102" href="Prelude.Apartness.html#162" class="Record Operator">//</a> <a id="1105" href="UTxO.HoareLogic.html#515" class="Datatype">Assertion</a>
  <a id="1117" href="UTxO.SL.html#1086" class="Function">Disjoint-LA</a> <a id="1129" class="Symbol">.</a><a id="1130" href="Prelude.Apartness.html#255" class="Field Operator">_♯_</a> <a id="1134" href="UTxO.SL.html#1134" class="Bound">l</a> <a id="1136" href="UTxO.SL.html#1136" class="Bound">P</a> <a id="1138" class="Symbol">=</a> <a id="1140" class="Symbol">∀</a> <a id="1142" href="UTxO.SL.html#1142" class="Bound">A</a> <a id="1144" class="Symbol">→</a> <a id="1146" href="UTxO.SL.html#451" class="Function">mod</a> <a id="1150" href="UTxO.SL.html#1142" class="Bound">A</a> <a id="1152" href="UTxO.SL.html#1134" class="Bound">l</a> <a id="1154" class="Symbol">→</a> <a id="1156" href="Relation.Nullary.html#665" class="Function Operator">¬</a> <a id="1158" href="UTxO.SL.html#573" class="Function">addr</a> <a id="1163" href="UTxO.SL.html#1142" class="Bound">A</a> <a id="1165" href="UTxO.SL.html#1136" class="Bound">P</a>

<a id="1168" class="Comment">-- ** Utility lemmas about separation.</a>

<a id="1208" class="Comment">-- ∈ᵈ-∪ : ⟨ s₁ ⊎ s₂ ⟩≡ s → A ∈ᵈ s → A ∈ᵈ s₁ ⊎ A ∈ᵈ s₂</a>
<a id="1262" class="Comment">-- ∈ᵈ-∪ {s₁}{s₂}{s}{A} (s₁♯s₂ , p) A∈ = ∈ᵈ-∪⁻ _ _ _ (∈ᵈ-cong (≈-sym p) A∈)</a>

<a id="1338" class="Comment">-- ∉ᵈ-∪ : ⟨ s₁ ⊎ s₂ ⟩≡ s → A ∉ᵈ s → A ∉ᵈ s₁ × A ∉ᵈ s₂</a>
<a id="1392" class="Comment">-- ∉ᵈ-∪ {s₁}{s₂}{s}{A} (s₁♯s₂ , p) A∉ = A∉ ∘ ∈ᵈ-cong p ∘ ∈ᵈ-∪⁺ˡ _ _ _ , A∉ ∘ ∈ᵈ-cong p ∘ ∈ᵈ-∪⁺ʳ _ _ _</a>

<a id="1495" class="Comment">-- ∈⇒addr : A ∈ᵈ s → P ∙ s → addr A P</a>
<a id="1533" class="Comment">-- ∈⇒addr {A}{s}{P = `emp} A∈ Ps = ⊥-elim $ Ps A A∈</a>
<a id="1585" class="Comment">-- ∈⇒addr {A}{s}{P = B `↦ v} A∈ Ps with A ≟ B</a>
<a id="1631" class="Comment">-- ... | yes A≡B = A≡B</a>
<a id="1654" class="Comment">-- ... | no  A≢B = ⊥-elim $ proj₂ Ps A A≢B A∈</a>
<a id="1700" class="Comment">-- ∈⇒addr {A}{s}{P = P `∗ Q} A∈ (s₁ , s₂ , ≡s , Ps₁ , Qs₂)</a>
<a id="1759" class="Comment">--   with ∈ᵈ-∪ ≡s A∈</a>
<a id="1780" class="Comment">-- ... | inj₁ A∈₁ = inj₁ $ ∈⇒addr {P = P} A∈₁ Ps₁</a>
<a id="1830" class="Comment">-- ... | inj₂ A∈₂ = inj₂ $ ∈⇒addr {P = Q} A∈₂ Qs₂</a>
<a id="1880" class="Comment">-- ∈⇒addr {A}{s}{P = P `∘⟦ l ⟧} A∈ Ps = ∈⇒addr {P = P} (⟦⟧ₗ-mono {l} s A A∈) Ps</a>

<a id="1961" class="Comment">-- ∉⇒¬addr : A ∉ᵈ s → P ∙ s → ¬ addr A P</a>
<a id="2002" class="Comment">-- ∉⇒¬addr {A}{s}{P = `emp} A∉ Ps ()</a>
<a id="2039" class="Comment">-- ∉⇒¬addr {A}{s}{P = .A `↦ _} A∉ (Ps , _) refl = A∉ $ ⁉⇒∈ᵈ (subst Is-just (sym Ps) auto)</a>
<a id="2129" class="Comment">-- ∉⇒¬addr {A}{s}{P = P `∗ Q} A∉ (s₁ , s₂ , ≡s , Ps₁ , Qs₂) A∈</a>
<a id="2192" class="Comment">--   with A∉ˡ , A∉ʳ ← ∉ᵈ-∪ ≡s A∉</a>
<a id="2225" class="Comment">--   with A∈</a>
<a id="2238" class="Comment">-- ... | inj₁ A∈ˡ = ∉⇒¬addr {P = P} A∉ˡ Ps₁ A∈ˡ</a>
<a id="2286" class="Comment">-- ... | inj₂ A∈ʳ = ∉⇒¬addr {P = Q} A∉ʳ Qs₂ A∈ʳ</a>
<a id="2334" class="Comment">-- ∉⇒¬addr {A}{s}{P = P `∘⟦ l ⟧} A∉ Ps A∈ = ∉⇒¬addr {P = P} (∉-⟦⟧ₗ {l = l} A∉) Ps A∈</a>

<a id="♯-skip"></a><a id="2420" href="UTxO.SL.html#2420" class="Function">♯-skip</a> <a id="2427" class="Symbol">:</a> <a id="2429" class="Symbol">(</a><a id="2430" href="UTxO.Ledger.html#1195" class="Generalizable">t</a> <a id="2432" class="InductiveConstructor Operator">∷</a> <a id="2434" href="UTxO.Ledger.html#1210" class="Generalizable">l</a><a id="2435" class="Symbol">)</a> <a id="2437" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="2439" href="UTxO.HoareLogic.html#940" class="Generalizable">P</a> <a id="2441" class="Symbol">→</a> <a id="2443" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="2445" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="2447" href="UTxO.HoareLogic.html#940" class="Generalizable">P</a>
<a id="2449" href="UTxO.SL.html#2420" class="Function">♯-skip</a> <a id="2456" href="UTxO.SL.html#2456" class="Bound">p</a> <a id="2458" href="UTxO.SL.html#2458" class="Bound">A</a> <a id="2460" class="Symbol">=</a> <a id="2462" href="UTxO.SL.html#2456" class="Bound">p</a> <a id="2464" href="UTxO.SL.html#2458" class="Bound">A</a> <a id="2466" href="Function.Base.html#1040" class="Function Operator">∘</a> <a id="2468" href="Data.List.Relation.Unary.Any.html#1281" class="InductiveConstructor">there</a>

<a id="2475" class="Comment">-- ♯⇒♯ : l ♯ s → s ♯ l</a>
<a id="2498" class="Comment">-- ♯⇒♯ {s = s} p A A∈ A∈l = p _ A∈l A∈</a>

<a id="♯♯⇒♯"></a><a id="2538" href="UTxO.SL.html#2538" class="Function">♯♯⇒♯</a> <a id="2543" class="Symbol">:</a> <a id="2545" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="2547" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="2549" href="UTxO.HoareLogic.html#962" class="Generalizable">R</a> <a id="2551" class="Symbol">→</a> <a id="2553" href="UTxO.HoareLogic.html#962" class="Generalizable">R</a> <a id="2555" href="UTxO.HoareLogic.html#1909" class="Function Operator">∙</a> <a id="2557" href="UTxO.Ledger.html#1175" class="Generalizable">s</a> <a id="2559" class="Symbol">→</a> <a id="2561" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="2563" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="2565" href="UTxO.Ledger.html#1175" class="Generalizable">s</a>
<a id="2567" href="UTxO.SL.html#2538" class="Function">♯♯⇒♯</a> <a id="2572" class="Symbol">{</a><a id="2573" href="UTxO.SL.html#2573" class="Bound">l</a><a id="2574" class="Symbol">}</a> <a id="2576" class="Symbol">{</a><a id="2577" href="UTxO.HoareLogic.html#541" class="InductiveConstructor">`emp</a><a id="2581" class="Symbol">}</a> <a id="2583" class="Symbol">{</a><a id="2584" href="UTxO.SL.html#2584" class="Bound">s</a><a id="2585" class="Symbol">}</a> <a id="2587" href="UTxO.SL.html#2587" class="Bound">l♯R</a> <a id="2591" href="UTxO.SL.html#2591" class="Bound">s∅</a> <a id="2594" class="Symbol">=</a> <a id="2596" class="Symbol">λ</a> <a id="2598" href="UTxO.SL.html#2598" class="Bound">_</a> <a id="2600" href="UTxO.SL.html#2600" class="Bound">_</a> <a id="2602" class="Symbol">(_</a> <a id="2605" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2607" class="Symbol">_</a> <a id="2609" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="2611" href="UTxO.SL.html#2611" class="Bound">utxo∈</a><a id="2616" class="Symbol">)</a> <a id="2618" class="Symbol">→</a> <a id="2620" href="UTxO.SL.html#2591" class="Bound">s∅</a> <a id="2623" class="Symbol">_</a> <a id="2625" href="UTxO.SL.html#2611" class="Bound">utxo∈</a>
<a id="2631" href="UTxO.SL.html#2538" class="Function">♯♯⇒♯</a> <a id="2636" class="Symbol">{</a><a id="2637" href="UTxO.SL.html#2637" class="Bound">l</a><a id="2638" class="Symbol">}</a> <a id="2640" class="Symbol">{</a><a id="2641" href="UTxO.SL.html#2641" class="Bound">A</a> <a id="2643" href="UTxO.HoareLogic.html#617" class="InductiveConstructor Operator">`↦</a> <a id="2646" href="UTxO.SL.html#2646" class="Bound">v</a><a id="2647" class="Symbol">}</a> <a id="2649" class="Symbol">{</a><a id="2650" href="UTxO.SL.html#2650" class="Bound">s</a><a id="2651" class="Symbol">}</a> <a id="2653" href="UTxO.SL.html#2653" class="Bound">l♯R</a> <a id="2657" href="UTxO.SL.html#2657" class="Bound">Rs</a> <a id="2660" class="Symbol">=</a> <a id="2662" class="Hole">{!!}</a>
<a id="2667" href="UTxO.SL.html#2538" class="Function">♯♯⇒♯</a> <a id="2672" class="Symbol">{</a><a id="2673" href="UTxO.SL.html#2673" class="Bound">l</a><a id="2674" class="Symbol">}</a> <a id="2676" class="Symbol">{</a><a id="2677" href="UTxO.SL.html#2677" class="Bound">R</a> <a id="2679" href="UTxO.HoareLogic.html#705" class="InductiveConstructor Operator">`∗</a> <a id="2682" href="UTxO.SL.html#2682" class="Bound">Q</a><a id="2683" class="Symbol">}</a> <a id="2685" class="Symbol">{</a><a id="2686" href="UTxO.SL.html#2686" class="Bound">s</a><a id="2687" class="Symbol">}</a> <a id="2689" href="UTxO.SL.html#2689" class="Bound">l♯R</a> <a id="2693" href="UTxO.SL.html#2693" class="Bound">Rs</a> <a id="2696" class="Symbol">=</a> <a id="2698" class="Hole">{!!}</a>
<a id="2703" href="UTxO.SL.html#2538" class="Function">♯♯⇒♯</a> <a id="2708" class="Symbol">{_}</a> <a id="2712" class="Symbol">{</a><a id="2713" href="UTxO.SL.html#2713" class="Bound">R</a> <a id="2715" href="UTxO.HoareLogic.html#776" class="InductiveConstructor Operator">`∘⟦</a> <a id="2719" href="UTxO.SL.html#2719" class="Bound">l</a> <a id="2721" href="UTxO.HoareLogic.html#776" class="InductiveConstructor Operator">⟧</a><a id="2722" class="Symbol">}</a> <a id="2724" class="Symbol">{</a><a id="2725" href="UTxO.SL.html#2725" class="Bound">s</a><a id="2726" class="Symbol">}</a> <a id="2728" href="UTxO.SL.html#2728" class="Bound">l♯R</a> <a id="2732" href="UTxO.SL.html#2732" class="Bound">Rs</a> <a id="2735" class="Symbol">=</a> <a id="2737" class="Hole">{!!}</a>

<a id="2743" class="Comment">-- ♯♯⇒♯ {l}{`emp}{s} l♯R s∅ A A∈ = s∅ A</a>
<a id="2783" class="Comment">-- ♯♯⇒♯ {l}{B `↦ v}{s} l♯R (_ , B↦) A A∈ A∈′</a>
<a id="2828" class="Comment">--   with A ≟ B</a>
<a id="2844" class="Comment">-- ... | yes refl = l♯R A A∈ refl</a>
<a id="2878" class="Comment">-- ... | no  A≢B  = B↦ A A≢B A∈′</a>
<a id="2911" class="Comment">-- ♯♯⇒♯ {l}{R `∗ Q}{s} l♯R (s₁ , s₂ , ≡s , Rs₁ , Qs₂) A A∈</a>
<a id="2970" class="Comment">--   with s₁ ⁉ A | inspect (s₁ ⁉_) A | s₂ ⁉ A | inspect (s₂ ⁉_) A</a>
<a id="3036" class="Comment">-- ... | just _  | ≡[ s₁≡ ] | _       | _</a>
<a id="3078" class="Comment">--     = ⊥-elim $ l♯R A A∈ $ inj₁ $ ∈⇒addr {A}{s₁}{R} (⁉⇒∈ᵈ $ subst Is-just (sym s₁≡) auto) Rs₁</a>
<a id="3174" class="Comment">-- ... | _       | _        | just _  | ≡[ s₂≡ ]</a>
<a id="3223" class="Comment">--     = ⊥-elim $ l♯R A A∈ $ inj₂ $ ∈⇒addr {A}{s₂}{Q} (⁉⇒∈ᵈ $ subst M.Is-just (sym s₂≡) auto) Qs₂</a>
<a id="3321" class="Comment">-- ... | nothing | ≡[ s₁≡ ] | nothing | ≡[ s₂≡ ]</a>
<a id="3370" class="Comment">--   = ∉-splits ≡s (⊥-elim ∘ ⁉⇒∉ᵈ (subst Is-nothing (sym s₁≡) auto))</a>
<a id="3439" class="Comment">--                 (⊥-elim ∘ ⁉⇒∉ᵈ (subst Is-nothing (sym s₂≡) auto))</a>
<a id="3508" class="Comment">-- ♯♯⇒♯ {_}{R `∘⟦ l ⟧}{s} l♯R Rs A A∈ = ¬A∈</a>
<a id="3552" class="Comment">--   where</a>
<a id="3563" class="Comment">--     A∉ : A ∉ᵈ ⟦ l ⟧ s</a>
<a id="3588" class="Comment">--     A∉ = ♯♯⇒♯ {R = R} {s = ⟦ l ⟧ s} l♯R Rs A A∈</a>

<a id="3640" class="Comment">--     ¬A∈ : A ∉ᵈ s</a>
<a id="3660" class="Comment">--     ¬A∈ = A∉ ∘ ⟦⟧ₗ-mono {l} s A</a>

<a id="3696" class="Comment">-- Helper lemma for [FRAME]: pushing ⟦ l ⟧ inside the partition.</a>
<a id="frame-helper"></a><a id="3761" href="UTxO.SL.html#3761" class="Function">frame-helper</a> <a id="3774" class="Symbol">:</a>
    <a id="3780" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="3782" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="3784" href="UTxO.HoareLogic.html#962" class="Generalizable">R</a>
  <a id="3788" class="Symbol">→</a> <a id="3790" href="UTxO.HoareLogic.html#962" class="Generalizable">R</a> <a id="3792" href="UTxO.HoareLogic.html#1909" class="Function Operator">∙</a> <a id="3794" href="UTxO.Ledger.html#1186" class="Generalizable">s₂</a>
  <a id="3799" class="Symbol">→</a> <a id="3801" href="UTxO.HoareLogic.html#977" class="Function Operator">⟨</a> <a id="3803" href="UTxO.Ledger.html#1183" class="Generalizable">s₁</a> <a id="3806" href="UTxO.HoareLogic.html#977" class="Function Operator">⊎</a> <a id="3808" href="UTxO.Ledger.html#1186" class="Generalizable">s₂</a> <a id="3811" href="UTxO.HoareLogic.html#977" class="Function Operator">⟩≡</a> <a id="3814" href="UTxO.Ledger.html#1175" class="Generalizable">s</a>
    <a id="3820" class="Comment">-----------------------</a>
  <a id="3846" class="Symbol">→</a> <a id="3848" href="UTxO.HoareLogic.html#977" class="Function Operator">⟨</a> <a id="3850" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="3852" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="3854" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="3856" href="UTxO.Ledger.html#1183" class="Generalizable">s₁</a> <a id="3859" href="UTxO.HoareLogic.html#977" class="Function Operator">⊎</a> <a id="3861" href="UTxO.Ledger.html#1186" class="Generalizable">s₂</a> <a id="3864" href="UTxO.HoareLogic.html#977" class="Function Operator">⟩≡</a> <a id="3867" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="3869" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="3871" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="3873" href="UTxO.Ledger.html#1175" class="Generalizable">s</a>
<a id="3875" href="UTxO.SL.html#3761" class="Function">frame-helper</a> <a id="3888" class="Symbol">{</a><a id="3889" class="Argument">l</a> <a id="3891" class="Symbol">=</a> <a id="3893" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3895" class="Symbol">}</a> <a id="3897" class="Symbol">_</a> <a id="3899" class="Symbol">_</a> <a id="3901" href="UTxO.SL.html#3901" class="Bound">p</a> <a id="3903" class="Symbol">=</a> <a id="3905" href="UTxO.SL.html#3901" class="Bound">p</a>
<a id="3907" href="UTxO.SL.html#3761" class="Function">frame-helper</a> <a id="3920" class="Symbol">{</a><a id="3921" class="Argument">l</a> <a id="3923" class="Symbol">=</a> <a id="3925" href="UTxO.SL.html#3925" class="Bound">tx</a> <a id="3928" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="3930" href="UTxO.SL.html#3930" class="Bound">l</a><a id="3931" class="Symbol">}{</a><a id="3933" href="UTxO.SL.html#3933" class="Bound">R</a><a id="3934" class="Symbol">}{</a><a id="3936" href="UTxO.SL.html#3936" class="Bound">s₂</a><a id="3938" class="Symbol">}{</a><a id="3940" href="UTxO.SL.html#3940" class="Bound">s₁</a><a id="3942" class="Symbol">}{</a><a id="3944" href="UTxO.SL.html#3944" class="Bound">s</a><a id="3945" class="Symbol">}</a> <a id="3947" href="UTxO.SL.html#3947" class="Bound">l♯R</a> <a id="3951" href="UTxO.SL.html#3951" class="Bound">Rs₂</a> <a id="3955" class="Symbol">(</a><a id="3956" href="UTxO.SL.html#3956" class="Bound">s₁♯s₂</a> <a id="3962" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="3964" href="UTxO.SL.html#3964" class="Bound">≡s</a><a id="3966" class="Symbol">)</a> <a id="3968" class="Symbol">=</a>
  <a id="3972" href="UTxO.SL.html#3761" class="Function">frame-helper</a> <a id="3985" class="Symbol">{</a><a id="3986" href="UTxO.SL.html#3930" class="Bound">l</a><a id="3987" class="Symbol">}{</a><a id="3989" href="UTxO.SL.html#3933" class="Bound">R</a><a id="3990" class="Symbol">}{</a><a id="3992" href="UTxO.SL.html#3936" class="Bound">s₂</a><a id="3994" class="Symbol">}{</a><a id="3996" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="3998" href="UTxO.SL.html#3925" class="Bound">tx</a> <a id="4001" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="4003" href="UTxO.SL.html#3940" class="Bound">s₁</a><a id="4005" class="Symbol">}{</a><a id="4007" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="4009" href="UTxO.SL.html#3925" class="Bound">tx</a> <a id="4012" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="4014" href="UTxO.SL.html#3944" class="Bound">s</a><a id="4015" class="Symbol">}</a> <a id="4017" class="Symbol">(</a><a id="4018" href="UTxO.SL.html#2420" class="Function">♯-skip</a> <a id="4025" class="Symbol">{</a><a id="4026" class="Argument">P</a> <a id="4028" class="Symbol">=</a> <a id="4030" href="UTxO.SL.html#3933" class="Bound">R</a><a id="4031" class="Symbol">}</a> <a id="4033" href="UTxO.SL.html#3947" class="Bound">l♯R</a><a id="4036" class="Symbol">)</a> <a id="4038" href="UTxO.SL.html#3951" class="Bound">Rs₂</a> <a id="4042" href="UTxO.SL.html#4193" class="Function">p′</a>
  <a id="4047" class="Keyword">where</a>
    <a id="4057" href="UTxO.SL.html#4057" class="Function">p₁</a> <a id="4060" class="Symbol">:</a> <a id="4062" class="Symbol">(</a><a id="4063" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="4065" href="UTxO.SL.html#3925" class="Bound">tx</a> <a id="4068" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="4070" href="UTxO.SL.html#3940" class="Bound">s₁</a><a id="4072" class="Symbol">)</a> <a id="4074" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="4076" href="UTxO.SL.html#3936" class="Bound">s₂</a>
    <a id="4083" href="UTxO.SL.html#4057" class="Function">p₁</a> <a id="4086" class="Symbol">=</a> <a id="4088" class="Hole">{!!}</a>
    <a id="4097" class="Comment">-- p₁ = transfer-helper s₁♯s₂ B∉₂</a>

    <a id="4136" href="UTxO.SL.html#4136" class="Function">p₂</a> <a id="4139" class="Symbol">:</a> <a id="4141" class="Symbol">((</a><a id="4143" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="4145" href="UTxO.SL.html#3925" class="Bound">tx</a> <a id="4148" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="4150" href="UTxO.SL.html#3940" class="Bound">s₁</a><a id="4152" class="Symbol">)</a> <a id="4154" href="Prelude.Sets.AsUniqueLists.Core.html#3203" class="Function Operator">∪</a> <a id="4156" href="UTxO.SL.html#3936" class="Bound">s₂</a><a id="4158" class="Symbol">)</a> <a id="4160" href="Prelude.Sets.AsUniqueLists.Core.html#5909" class="Function Operator">≈ˢ</a> <a id="4163" class="Symbol">(</a><a id="4164" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="4166" href="UTxO.SL.html#3925" class="Bound">tx</a> <a id="4169" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="4171" href="UTxO.SL.html#3944" class="Bound">s</a><a id="4172" class="Symbol">)</a>
    <a id="4178" href="UTxO.SL.html#4136" class="Function">p₂</a> <a id="4181" class="Symbol">=</a> <a id="4183" class="Hole">{!!}</a>

    <a id="4193" href="UTxO.SL.html#4193" class="Function">p′</a> <a id="4196" class="Symbol">:</a> <a id="4198" href="UTxO.HoareLogic.html#977" class="Function Operator">⟨</a> <a id="4200" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="4202" href="UTxO.SL.html#3925" class="Bound">tx</a> <a id="4205" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="4207" href="UTxO.SL.html#3940" class="Bound">s₁</a> <a id="4210" href="UTxO.HoareLogic.html#977" class="Function Operator">⊎</a> <a id="4212" href="UTxO.SL.html#3936" class="Bound">s₂</a> <a id="4215" href="UTxO.HoareLogic.html#977" class="Function Operator">⟩≡</a> <a id="4218" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="4220" href="UTxO.SL.html#3925" class="Bound">tx</a> <a id="4223" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="4225" href="UTxO.SL.html#3944" class="Bound">s</a>
    <a id="4231" href="UTxO.SL.html#4193" class="Function">p′</a> <a id="4234" class="Symbol">=</a> <a id="4236" href="UTxO.SL.html#4057" class="Function">p₁</a> <a id="4239" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4241" href="UTxO.SL.html#4136" class="Function">p₂</a>


<a id="4246" class="Comment">{-
frame-helper {l = l₀@(A —→⟨ v ⟩ B ∷ l)}{R}{s₂}{s₁}{s} l♯R Rs₂ (s₁♯s₂ , ≡s) =
  frame-helper {l}{R}{s₂}{run [ A ∣ v ↦ B ] s₁} {run [ A ∣ v ↦ B ] s} (♯-skip {P = R} l♯R) Rs₂ p′
  where
    l♯s₂ : l₀ ♯ s₂
    l♯s₂ = ♯♯⇒♯ {R = R} l♯R Rs₂

    A∉₂ : A ∉ᵈ s₂
    A∉₂ = l♯s₂ A $ here (here refl)

    B∉₂ : B ∉ᵈ s₂
    B∉₂ = l♯s₂ B $ here (there (here refl))

    p₁ : (run [ A ∣ v ↦ B ] s₁) Map.♯ s₂
    p₁ = transfer-helper s₁♯s₂ B∉₂

    ∉⇒≢ : ∀ k → k ∈ᵈ s₂ → (k ≢ A) × (k ≢ B)
    ∉⇒≢ k k∈ = k≢A , k≢B
      where
        k∉ : ¬ mod k l₀
        k∉ = ♯⇒♯ l♯s₂ k k∈

        k≢A : k ≢ A
        k≢A refl = ⊥-elim $ k∉ (here (here refl))

        k≢B : k ≢ B
        k≢B refl = ⊥-elim $ k∉ (here (there (here refl)))

    p₂ : (run [ A ∣ v ↦ B ] s₁) ∪ s₂ ≈ run [ A ∣ v ↦ B ] s
    p₂ k
      with eq ← ≡s k
      with eqᵃ ← ≡s A
      with eqᵇ ← ≡s B
      with ¿ k ∈ᵈ s₂ ¿
    ... | yes k∈
      with k≢A , k≢B ← ∉⇒≢ k k∈
      rewrite ∪-chooseᵣ p₁ k∈
            | ∪-chooseᵣ s₁♯s₂ k∈
            | drop-[∣↦] {v = v} {s = s} k k≢A k≢B
            = eq
    ... | no k∉
      rewrite ∪-chooseₗ p₁ k∉
            | ∪-chooseₗ s₁♯s₂ k∉
      with s₁ ⁉ A | inspect (s₁ ⁉_) A
         | s  ⁉ A | inspect (s  ⁉_) A
         | eqᵃ
    ... | nothing | _ | nothing | _ | _ = eq
    ... | nothing | ≡[ s₁A≡ ] | just _  | ≡[ sA≡ ] | _
        = let p = ↦-∪⁺ʳ {s₂ = s₂} $ ⁉⇒∉ᵈ (subst Is-nothing (sym s₁A≡) auto)
          in ⊥-elim $ A∉₂ $ ⁉⇒∈ᵈ $ subst Is-just (sym $ trans p (trans eqᵃ sA≡)) auto
    ... | just vᵃ | ≡[ s₁A≡ ] | nothing | _ | eqᵃ′
        = case trans (sym $ (↦-∪⁺ˡ {s₂ = s₂} s₁A≡)) eqᵃ′ of λ ()
    ... | just vᵃ  | ≡[ s₁A≡ ] | just vᵃ′ | _ | eqᵃ′
      with vᵃ ≟ vᵃ′
    ... | no neq = ⊥-elim $ neq $ M.just-injective $ trans (sym $ ↦-∪⁺ˡ {s₂ = s₂} s₁A≡) eqᵃ′
    ... | yes refl
      with s₁ ⁉ B | inspect (s₁ ⁉_) B
         | s  ⁉ B | inspect (s  ⁉_) B
         | eqᵇ
    ... | nothing | _ | nothing | _ | _
        = eq
    ... | nothing | ≡[ s₁B≡ ] | just _  | ≡[ sB≡ ] | _
        = let p = ↦-∪⁺ʳ {s₂ = s₂} $ ⁉⇒∉ᵈ (subst Is-nothing (sym s₁B≡) auto)
          in ⊥-elim $ B∉₂ $ ⁉⇒∈ᵈ $ subst Is-just (sym $ trans p (trans eqᵇ sB≡)) auto
    ... | just vᵇ | ≡[ s₁B≡ ] | nothing | _ | eqᵇ′
        = case trans (sym $ (↦-∪⁺ˡ {s₂ = s₂} s₁B≡)) eqᵇ′ of λ ()
    ... | just vᵇ  | ≡[ s₁B≡ ] | just vᵇ′ | _ | eqᵇ′
      with vᵇ ≟ vᵇ′
    ... | no neq = ⊥-elim $ neq $ M.just-injective $ trans (sym $ ↦-∪⁺ˡ {s₂ = s₂} s₁B≡) eqᵇ′
    ... | yes refl
      with v ≤? vᵃ
    ... | no  _ = eq
    ... | yes _ = ≡-cong-update $ ≡-cong-update eq

    p′ : ⟨ run [ A ∣ v ↦ B ] s₁ ⊎ s₂ ⟩≡ run [ A ∣ v ↦ B ] s
    p′ = p₁ , p₂
-}</a>

<a id="6865" class="Comment">-- The proof of the frame rule from separation logic, allowing us to prove formulas in minimal contexts</a>
<a id="6969" class="Comment">-- and then weaken our results to the desired context (assuming the rest of the context is disjoint).</a>
<a id="[FRAME]"></a><a id="7071" href="UTxO.SL.html#7071" class="Function">[FRAME]</a> <a id="7079" class="Symbol">:</a> <a id="7081" class="Symbol">∀</a> <a id="7083" href="UTxO.SL.html#7083" class="Bound">R</a>
  <a id="7087" class="Symbol">→</a> <a id="7089" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="7091" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="7093" href="UTxO.SL.html#7083" class="Bound">R</a>
  <a id="7097" class="Symbol">→</a> <a id="7099" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟨</a> <a id="7101" href="UTxO.HoareLogic.html#940" class="Generalizable">P</a> <a id="7103" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟩</a> <a id="7105" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="7107" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟨</a> <a id="7109" href="UTxO.HoareLogic.html#951" class="Generalizable">Q</a> <a id="7111" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟩</a>
    <a id="7117" class="Comment">-----------------------</a>
  <a id="7143" class="Symbol">→</a> <a id="7145" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟨</a> <a id="7147" href="UTxO.HoareLogic.html#940" class="Generalizable">P</a> <a id="7149" href="UTxO.HoareLogic.html#705" class="InductiveConstructor Operator">`∗</a> <a id="7152" href="UTxO.SL.html#7083" class="Bound">R</a> <a id="7154" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟩</a> <a id="7156" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="7158" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟨</a> <a id="7160" href="UTxO.HoareLogic.html#951" class="Generalizable">Q</a> <a id="7162" href="UTxO.HoareLogic.html#705" class="InductiveConstructor Operator">`∗</a> <a id="7165" href="UTxO.SL.html#7083" class="Bound">R</a> <a id="7167" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟩</a>
<a id="7169" href="UTxO.SL.html#7071" class="Function">[FRAME]</a> <a id="7177" class="Symbol">{</a><a id="7178" href="UTxO.SL.html#7178" class="Bound">l</a><a id="7179" class="Symbol">}{</a><a id="7181" href="UTxO.SL.html#7181" class="Bound">P</a><a id="7182" class="Symbol">}{</a><a id="7184" href="UTxO.SL.html#7184" class="Bound">Q</a><a id="7185" class="Symbol">}</a> <a id="7187" href="UTxO.SL.html#7187" class="Bound">R</a> <a id="7189" href="UTxO.SL.html#7189" class="Bound">l♯R</a> <a id="7193" href="UTxO.SL.html#7193" class="Bound">PlQ</a> <a id="7197" class="Symbol">=</a> <a id="7199" href="UTxO.HoareLogic.html#3070" class="Function">denot⇒axiom</a> <a id="7211" href="UTxO.SL.html#7225" class="Function">d</a>
  <a id="7215" class="Keyword">where</a>
    <a id="7225" href="UTxO.SL.html#7225" class="Function">d</a> <a id="7227" class="Symbol">:</a> <a id="7229" class="Symbol">(</a><a id="7230" href="UTxO.SL.html#7181" class="Bound">P</a> <a id="7232" href="UTxO.HoareLogic.html#705" class="InductiveConstructor Operator">`∗</a> <a id="7235" href="UTxO.SL.html#7187" class="Bound">R</a><a id="7236" class="Symbol">)</a> <a id="7238" href="UTxO.HoareLogic.html#1847" class="Function Operator">`⊢</a> <a id="7241" class="Symbol">(</a><a id="7242" href="UTxO.SL.html#7184" class="Bound">Q</a> <a id="7244" href="UTxO.HoareLogic.html#705" class="InductiveConstructor Operator">`∗</a> <a id="7247" href="UTxO.SL.html#7187" class="Bound">R</a><a id="7248" class="Symbol">)</a> <a id="7250" href="UTxO.HoareLogic.html#776" class="InductiveConstructor Operator">`∘⟦</a> <a id="7254" href="UTxO.SL.html#7178" class="Bound">l</a> <a id="7256" href="UTxO.HoareLogic.html#776" class="InductiveConstructor Operator">⟧</a>
    <a id="7262" href="UTxO.SL.html#7225" class="Function">d</a> <a id="7264" class="Symbol">{</a><a id="7265" href="UTxO.SL.html#7265" class="Bound">s</a><a id="7266" class="Symbol">}</a> <a id="7268" class="Symbol">(</a><a id="7269" href="UTxO.SL.html#7269" class="Bound">s₁</a> <a id="7272" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7274" href="UTxO.SL.html#7274" class="Bound">s₂</a> <a id="7277" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7279" href="UTxO.SL.html#7279" class="Bound">s₁♯s₂</a> <a id="7285" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7287" href="UTxO.SL.html#7287" class="Bound">Ps₁</a> <a id="7291" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7293" href="UTxO.SL.html#7293" class="Bound">Rs₂</a><a id="7296" class="Symbol">)</a> <a id="7298" class="Symbol">=</a> <a id="7300" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="7302" href="UTxO.SL.html#7178" class="Bound">l</a> <a id="7304" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="7306" href="UTxO.SL.html#7269" class="Bound">s₁</a> <a id="7309" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7311" href="UTxO.SL.html#7274" class="Bound">s₂</a>  <a id="7315" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7317" href="UTxO.SL.html#7416" class="Function">p</a> <a id="7319" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7321" href="UTxO.SL.html#7352" class="Function">Qs₁′</a> <a id="7326" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="7328" href="UTxO.SL.html#7293" class="Bound">Rs₂</a>
      <a id="7338" class="Keyword">where</a>
        <a id="7352" href="UTxO.SL.html#7352" class="Function">Qs₁′</a> <a id="7357" class="Symbol">:</a> <a id="7359" href="UTxO.SL.html#7184" class="Bound">Q</a> <a id="7361" href="UTxO.HoareLogic.html#1909" class="Function Operator">∙</a> <a id="7363" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="7365" href="UTxO.SL.html#7178" class="Bound">l</a> <a id="7367" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="7369" href="UTxO.SL.html#7269" class="Bound">s₁</a>
        <a id="7380" href="UTxO.SL.html#7352" class="Function">Qs₁′</a> <a id="7385" class="Symbol">=</a> <a id="7387" href="UTxO.HoareLogic.html#2887" class="Function">axiom⇒denot</a> <a id="7399" href="UTxO.SL.html#7193" class="Bound">PlQ</a> <a id="7403" href="UTxO.SL.html#7287" class="Bound">Ps₁</a>

        <a id="7416" href="UTxO.SL.html#7416" class="Function">p</a> <a id="7418" class="Symbol">:</a> <a id="7420" href="UTxO.HoareLogic.html#977" class="Function Operator">⟨</a> <a id="7422" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="7424" href="UTxO.SL.html#7178" class="Bound">l</a> <a id="7426" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="7428" href="UTxO.SL.html#7269" class="Bound">s₁</a> <a id="7431" href="UTxO.HoareLogic.html#977" class="Function Operator">⊎</a> <a id="7433" href="UTxO.SL.html#7274" class="Bound">s₂</a> <a id="7436" href="UTxO.HoareLogic.html#977" class="Function Operator">⟩≡</a> <a id="7439" href="UTxO.Ledger.html#563" class="Field Operator">⟦</a> <a id="7441" href="UTxO.SL.html#7178" class="Bound">l</a> <a id="7443" href="UTxO.Ledger.html#563" class="Field Operator">⟧</a> <a id="7445" href="UTxO.SL.html#7265" class="Bound">s</a>
        <a id="7455" href="UTxO.SL.html#7416" class="Function">p</a> <a id="7457" class="Symbol">=</a> <a id="7459" href="UTxO.SL.html#3761" class="Function">frame-helper</a> <a id="7472" class="Symbol">{</a><a id="7473" class="Argument">R</a> <a id="7475" class="Symbol">=</a> <a id="7477" href="UTxO.SL.html#7187" class="Bound">R</a><a id="7478" class="Symbol">}</a> <a id="7480" href="UTxO.SL.html#7189" class="Bound">l♯R</a> <a id="7484" href="UTxO.SL.html#7293" class="Bound">Rs₂</a> <a id="7488" href="UTxO.SL.html#7279" class="Bound">s₁♯s₂</a>

<a id="7495" class="Keyword">open</a> <a id="7500" href="UTxO.HoareLogic.html#3936" class="Module">HoareReasoning</a>
<a id="ℝ[FRAME]"></a><a id="7515" href="UTxO.SL.html#7515" class="Function">ℝ[FRAME]</a> <a id="7524" class="Symbol">:</a> <a id="7526" class="Symbol">∀</a> <a id="7528" href="UTxO.SL.html#7528" class="Bound">R</a>
  <a id="7532" class="Symbol">→</a> <a id="7534" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="7536" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="7538" href="UTxO.SL.html#7528" class="Bound">R</a>
  <a id="7542" class="Symbol">→</a> <a id="7544" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟨</a> <a id="7546" href="UTxO.HoareLogic.html#940" class="Generalizable">P</a> <a id="7548" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟩</a> <a id="7550" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="7552" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟨</a> <a id="7554" href="UTxO.HoareLogic.html#951" class="Generalizable">Q</a> <a id="7556" href="UTxO.HoareLogic.html#2038" class="Datatype Operator">⟩</a>
    <a id="7562" class="Comment">-----------------------</a>
  <a id="7588" class="Symbol">→</a> <a id="7590" href="UTxO.HoareLogic.html#4019" class="Record Operator">ℝ⟨</a> <a id="7593" href="UTxO.HoareLogic.html#940" class="Generalizable">P</a> <a id="7595" href="UTxO.HoareLogic.html#705" class="InductiveConstructor Operator">`∗</a> <a id="7598" href="UTxO.SL.html#7528" class="Bound">R</a> <a id="7600" href="UTxO.HoareLogic.html#4019" class="Record Operator">⟩</a> <a id="7602" href="UTxO.Ledger.html#1210" class="Generalizable">l</a> <a id="7604" href="UTxO.HoareLogic.html#4019" class="Record Operator">⟨</a> <a id="7606" href="UTxO.HoareLogic.html#951" class="Generalizable">Q</a> <a id="7608" href="UTxO.HoareLogic.html#705" class="InductiveConstructor Operator">`∗</a> <a id="7611" href="UTxO.SL.html#7528" class="Bound">R</a> <a id="7613" href="UTxO.HoareLogic.html#4019" class="Record Operator">⟩</a>
<a id="7615" href="UTxO.SL.html#7515" class="Function">ℝ[FRAME]</a> <a id="7624" class="Symbol">{</a><a id="7625" class="Argument">l</a> <a id="7627" class="Symbol">=</a> <a id="7629" href="UTxO.SL.html#7629" class="Bound">l</a><a id="7630" class="Symbol">}</a> <a id="7632" href="UTxO.SL.html#7632" class="Bound">R</a> <a id="7634" href="UTxO.SL.html#7634" class="Bound">l♯R</a> <a id="7638" href="UTxO.SL.html#7638" class="Bound">PlQ</a> <a id="7642" class="Symbol">=</a> <a id="7644" href="UTxO.HoareLogic.html#4098" class="InductiveConstructor Operator">mkℝ</a> <a id="7648" href="UTxO.SL.html#7071" class="Function">[FRAME]</a> <a id="7656" class="Symbol">{</a><a id="7657" class="Argument">l</a> <a id="7659" class="Symbol">=</a> <a id="7661" href="UTxO.SL.html#7629" class="Bound">l</a><a id="7662" class="Symbol">}</a> <a id="7664" href="UTxO.SL.html#7632" class="Bound">R</a> <a id="7666" href="UTxO.SL.html#7634" class="Bound">l♯R</a> <a id="7670" href="UTxO.SL.html#7638" class="Bound">PlQ</a>
</pre></body></html>