<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>UTxOErr.SL</title><link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css'/><style>.github-fork-ribbon:before { background-color: #333; }</style><link rel="stylesheet" href="css/Agda.css"></head><body><a class='github-fork-ribbon'href='https://github.com/omelkonian/hoare-ledgers/tree/master/UTxOErr/SL.agda'data-ribbon='Source code on Github' title='Source code on Github'>Source code on Github</a><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--allow-unsolved-metas</a> <a id="36" class="Symbol">#-}</a>
<a id="40" class="Comment">---------------------------</a>
<a id="68" class="Comment">-- ** Separation logic (SL)</a>

<a id="97" class="Keyword">module</a> <a id="104" href="UTxOErr.SL.html" class="Module">UTxOErr.SL</a> <a id="115" class="Keyword">where</a>

<a id="122" class="Keyword">open</a> <a id="127" class="Keyword">import</a> <a id="134" href="Prelude.Init.html" class="Module">Prelude.Init</a><a id="146" class="Symbol">;</a> <a id="148" class="Keyword">open</a> <a id="153" href="Prelude.Init.html#504" class="Module">SetAsType</a>
<a id="163" class="Keyword">open</a> <a id="168" class="Keyword">import</a> <a id="175" href="Prelude.DecEq.html" class="Module">Prelude.DecEq</a>
<a id="189" class="Keyword">open</a> <a id="194" class="Keyword">import</a> <a id="201" href="Prelude.Decidable.html" class="Module">Prelude.Decidable</a>
<a id="219" class="Keyword">open</a> <a id="224" class="Keyword">import</a> <a id="231" href="Prelude.Ord.html" class="Module">Prelude.Ord</a>
<a id="243" class="Keyword">open</a> <a id="248" class="Keyword">import</a> <a id="255" href="Prelude.General.html" class="Module">Prelude.General</a>
<a id="271" class="Keyword">open</a> <a id="276" class="Keyword">import</a> <a id="283" href="Prelude.InferenceRules.html" class="Module">Prelude.InferenceRules</a>
<a id="306" class="Keyword">open</a> <a id="311" class="Keyword">import</a> <a id="318" href="Prelude.Apartness.html" class="Module">Prelude.Apartness</a>
<a id="336" class="Keyword">open</a> <a id="341" class="Keyword">import</a> <a id="348" href="Prelude.Semigroup.html" class="Module">Prelude.Semigroup</a>
<a id="366" class="Keyword">open</a> <a id="371" class="Keyword">import</a> <a id="378" href="Prelude.Functor.html" class="Module">Prelude.Functor</a>
<a id="394" class="Keyword">open</a> <a id="399" class="Keyword">import</a> <a id="406" href="Prelude.Monoid.html" class="Module">Prelude.Monoid</a>
<a id="421" class="Keyword">open</a> <a id="426" class="Keyword">import</a> <a id="433" href="Prelude.Membership.html" class="Module">Prelude.Membership</a>

<a id="453" class="Keyword">open</a> <a id="458" class="Keyword">import</a> <a id="465" href="UTxOErr.UTxO.html" class="Module">UTxOErr.UTxO</a>
<a id="478" class="Keyword">open</a> <a id="483" class="Keyword">import</a> <a id="490" href="UTxOErr.Ledger.html" class="Module">UTxOErr.Ledger</a>
<a id="505" class="Keyword">open</a> <a id="510" class="Keyword">import</a> <a id="517" href="UTxOErr.HoareLogic.html" class="Module">UTxOErr.HoareLogic</a>
<a id="536" class="Keyword">open</a> <a id="541" class="Keyword">import</a> <a id="548" href="UTxOErr.HoareProperties.html" class="Module">UTxOErr.HoareProperties</a>
<a id="572" class="Comment">-- open import UTxOErr.Maps</a>
<a id="600" class="Keyword">open</a> <a id="605" class="Keyword">import</a> <a id="612" href="Prelude.Maps.html" class="Module">Prelude.Maps</a>
<a id="625" class="Keyword">open</a> <a id="630" class="Keyword">import</a> <a id="637" href="Prelude.Setoid.html" class="Module">Prelude.Setoid</a>

<a id="⊎-⟦⟧ᵗ"></a><a id="653" href="UTxOErr.SL.html#653" class="Function">⊎-⟦⟧ᵗ</a> <a id="659" class="Symbol">:</a> <a id="661" class="Symbol">∀</a> <a id="663" href="UTxOErr.SL.html#663" class="Bound">s₁′</a> <a id="667" class="Symbol">→</a>
  <a id="671" href="Prelude.InferenceRules.html#56141" class="Function Operator">∙</a> <a id="673" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="675" href="UTxOErr.Ledger.html#638" class="Generalizable">t</a> <a id="677" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="679" href="UTxOErr.Ledger.html#585" class="Generalizable">s₁</a> <a id="682" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="684" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="689" href="UTxOErr.SL.html#663" class="Bound">s₁′</a>
  <a id="695" href="Prelude.InferenceRules.html#56072" class="Function Operator">∙</a> <a id="697" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟨</a> <a id="699" href="UTxOErr.Ledger.html#585" class="Generalizable">s₁</a> <a id="702" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⊎</a> <a id="704" href="UTxOErr.Ledger.html#596" class="Generalizable">s₂</a> <a id="707" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟩≡</a> <a id="710" href="UTxOErr.Ledger.html#577" class="Generalizable">s</a>
    <a id="716" href="Prelude.InferenceRules.html#13760" class="Function Operator">────────────────────────────────</a>
    <a id="753" href="UTxOErr.HoareLogic.html#1196" class="Function">lift↑</a> <a id="759" class="Symbol">(</a><a id="760" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟨</a> <a id="762" href="UTxOErr.SL.html#663" class="Bound">s₁′</a> <a id="766" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⊎</a> <a id="768" href="UTxOErr.Ledger.html#596" class="Generalizable">s₂</a> <a id="771" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟩≡_</a><a id="774" class="Symbol">)</a> <a id="776" class="Symbol">(</a><a id="777" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="779" href="UTxOErr.Ledger.html#638" class="Generalizable">t</a> <a id="781" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="783" href="UTxOErr.Ledger.html#577" class="Generalizable">s</a><a id="784" class="Symbol">)</a>
<a id="786" href="UTxOErr.SL.html#653" class="Function">⊎-⟦⟧ᵗ</a> <a id="792" class="Symbol">{</a><a id="793" href="UTxOErr.SL.html#793" class="Bound">t</a><a id="794" class="Symbol">}{</a><a id="796" href="UTxOErr.SL.html#796" class="Bound">s₁</a><a id="798" class="Symbol">}{</a><a id="800" href="UTxOErr.SL.html#800" class="Bound">s₂</a><a id="802" class="Symbol">}{</a><a id="804" href="UTxOErr.SL.html#804" class="Bound">s</a><a id="805" class="Symbol">}</a> <a id="807" href="UTxOErr.SL.html#807" class="Bound">s₁′</a> <a id="811" href="UTxOErr.SL.html#811" class="Bound">eq</a> <a id="814" class="Symbol">(</a><a id="815" href="UTxOErr.SL.html#815" class="Bound">s₁♯s₂</a> <a id="821" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="823" href="UTxOErr.SL.html#823" class="Bound">≡s</a><a id="825" class="Symbol">)</a>
  <a id="829" class="Keyword">with</a> <a id="834" href="UTxOErr.UTxO.html#5093" class="Function">isValidTx?</a> <a id="845" href="UTxOErr.SL.html#793" class="Bound">t</a> <a id="847" href="UTxOErr.SL.html#796" class="Bound">s₁</a>
<a id="850" class="Symbol">...</a> <a id="854" class="Symbol">|</a> <a id="856" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="860" href="UTxOErr.SL.html#860" class="Bound">valid-s₁</a>
  <a id="871" class="Keyword">with</a> <a id="876" href="UTxOErr.UTxO.html#5093" class="Function">isValidTx?</a> <a id="887" class="Bound">t</a> <a id="889" class="Bound">s</a>
<a id="891" class="Symbol">...</a> <a id="895" class="Symbol">|</a> <a id="897" href="Relation.Nullary.html#1694" class="InductiveConstructor">no</a> <a id="900" href="UTxOErr.SL.html#900" class="Bound">¬valid</a>
  <a id="909" class="Symbol">=</a> <a id="911" href="Data.Empty.html#637" class="Function">⊥-elim</a> <a id="918" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="920" href="UTxOErr.SL.html#900" class="Bound">¬valid</a> <a id="927" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="929" class="Keyword">record</a>
    <a id="940" class="Symbol">{</a> <a id="942" href="UTxOErr.UTxO.html#3822" class="Field">validOutputRefs</a> <a id="958" class="Symbol">=</a> <a id="960" href="UTxOErr.SL.html#1184" class="Function">vor</a>
    <a id="968" class="Symbol">;</a> <a id="970" href="UTxOErr.UTxO.html#4066" class="Field">preservesValues</a> <a id="986" class="Symbol">=</a> <a id="988" href="UTxOErr.SL.html#1154" class="Function">pv</a>
    <a id="995" class="Symbol">;</a> <a id="997" href="UTxOErr.UTxO.html#3768" class="Field">noDoubleSpending</a> <a id="1014" class="Symbol">=</a> <a id="1016" class="Bound">valid-s₁</a> <a id="1025" class="Symbol">.</a><a id="1026" href="UTxOErr.UTxO.html#3768" class="Field">noDoubleSpending</a>
    <a id="1047" class="Symbol">;</a> <a id="1049" href="UTxOErr.UTxO.html#4164" class="Field">allInputsValidate</a> <a id="1067" class="Symbol">=</a> <a id="1069" href="UTxOErr.SL.html#1168" class="Function">aiv</a> <a id="1073" class="Comment">-- valid-s₁ .allInputsValidate</a>
    <a id="1108" class="Symbol">;</a> <a id="1110" href="UTxOErr.UTxO.html#4261" class="Field">validateValidHashes</a> <a id="1130" class="Symbol">=</a> <a id="1132" href="UTxOErr.SL.html#1358" class="Function">vvh</a>
    <a id="1140" class="Symbol">}</a>
  <a id="1144" class="Keyword">where</a>
    <a id="1154" href="UTxOErr.SL.html#1154" class="Function">pv</a> <a id="1157" class="Symbol">=</a> <a id="1159" class="Hole">{!!}</a>
    <a id="1168" href="UTxOErr.SL.html#1168" class="Function">aiv</a> <a id="1172" class="Symbol">=</a> <a id="1174" class="Hole">{!!}</a>

    <a id="1184" href="UTxOErr.SL.html#1184" class="Function">vor</a> <a id="1188" class="Symbol">:</a> <a id="1190" href="Data.List.Relation.Unary.All.html#1453" class="Datatype">All</a> <a id="1194" class="Symbol">(</a><a id="1195" href="Prelude.Maps.AsSets.html#1627" class="Function Operator">_∈ᵈ</a> <a id="1199" class="Bound">s</a><a id="1200" class="Symbol">)</a> <a id="1202" class="Symbol">(</a><a id="1203" href="Common.html#2104" class="Function">outputRefs</a> <a id="1214" class="Bound">t</a><a id="1215" class="Symbol">)</a>
    <a id="1221" href="UTxOErr.SL.html#1184" class="Function">vor</a> <a id="1225" class="Symbol">=</a> <a id="1227" class="Hole">{!!}</a>

    <a id="1237" class="Comment">-- vvh : All (λ i → M.Any.Any (λ o → o .address ≡ i .validator ♯) (getSpentOutput s i))</a>
    <a id="1329" class="Comment">--           (t .inputs)</a>
    <a id="1358" href="UTxOErr.SL.html#1358" class="Function">vvh</a> <a id="1362" class="Symbol">=</a> <a id="1364" class="Hole">{!!}</a>

<a id="1370" class="Symbol">...</a> <a id="1374" class="Symbol">|</a> <a id="1376" href="Relation.Nullary.html#1657" class="InductiveConstructor">yes</a> <a id="1380" href="UTxOErr.SL.html#1380" class="Bound">valid-s</a>
  <a id="1390" class="Symbol">=</a> <a id="1392" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="1397" class="Symbol">(</a><a id="1398" href="UTxOErr.SL.html#1510" class="Function">s₁♯s₂′</a> <a id="1405" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="1407" href="UTxOErr.SL.html#1551" class="Function">≡s′</a><a id="1410" class="Symbol">)</a>
  <a id="1414" class="Keyword">where</a>
    <a id="1424" href="UTxOErr.SL.html#1424" class="Function">s₁≡</a> <a id="1428" class="Symbol">:</a> <a id="1430" class="Bound">s₁′</a> <a id="1434" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="1436" class="Symbol">(</a><a id="1437" class="Bound">s₁</a> <a id="1440" href="UTxOErr.UTxO.html#1538" class="Function Operator">─ᵏˢ</a> <a id="1444" href="Common.html#2104" class="Function">outputRefs</a> <a id="1455" class="Bound">t</a><a id="1456" class="Symbol">)</a> <a id="1458" href="Prelude.Maps.AsSets.html#1469" class="Function Operator">∪</a> <a id="1460" href="UTxOErr.UTxO.html#1177" class="Function">utxoTx</a> <a id="1467" class="Bound">t</a>
    <a id="1473" href="UTxOErr.SL.html#1424" class="Function">s₁≡</a> <a id="1477" class="Symbol">=</a> <a id="1479" href="Relation.Binary.PropositionalEquality.Core.html#1693" class="Function">sym</a> <a id="1483" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="1485" href="Data.Maybe.Properties.html#946" class="Function">M.just-injective</a> <a id="1502" class="Bound">eq</a>

    <a id="1510" href="UTxOErr.SL.html#1510" class="Function">s₁♯s₂′</a> <a id="1517" class="Symbol">:</a> <a id="1519" class="Bound">s₁′</a> <a id="1523" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="1525" class="Bound">s₂</a>
    <a id="1532" href="UTxOErr.SL.html#1510" class="Function">s₁♯s₂′</a> <a id="1539" class="Symbol">=</a> <a id="1541" class="Hole">{!!}</a>

    <a id="1551" href="UTxOErr.SL.html#1551" class="Function">≡s′</a> <a id="1555" class="Symbol">:</a> <a id="1557" class="Bound">s₁′</a> <a id="1561" href="Prelude.Maps.AsSets.html#1469" class="Function Operator">∪</a> <a id="1563" class="Bound">s₂</a> <a id="1566" href="Prelude.Setoid.Core.html#191" class="Field Operator">≈</a> <a id="1568" class="Symbol">((</a><a id="1570" class="Bound">s</a> <a id="1572" href="UTxOErr.UTxO.html#1538" class="Function Operator">─ᵏˢ</a> <a id="1576" href="Common.html#2104" class="Function">outputRefs</a> <a id="1587" class="Bound">t</a><a id="1588" class="Symbol">)</a> <a id="1590" href="Prelude.Maps.AsSets.html#1469" class="Function Operator">∪</a> <a id="1592" href="UTxOErr.UTxO.html#1177" class="Function">utxoTx</a> <a id="1599" class="Bound">t</a><a id="1600" class="Symbol">)</a>
    <a id="1606" href="UTxOErr.SL.html#1551" class="Function">≡s′</a> <a id="1610" class="Symbol">=</a> <a id="1612" class="Hole">{!!}</a>

<a id="⊎-⟦⟧ᵗ˘"></a><a id="1618" href="UTxOErr.SL.html#1618" class="Function">⊎-⟦⟧ᵗ˘</a> <a id="1625" class="Symbol">:</a> <a id="1627" class="Symbol">∀</a> <a id="1629" href="UTxOErr.SL.html#1629" class="Bound">s₂′</a> <a id="1633" class="Symbol">→</a>
  <a id="1637" href="Prelude.InferenceRules.html#56141" class="Function Operator">∙</a> <a id="1639" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="1641" href="UTxOErr.Ledger.html#638" class="Generalizable">t</a> <a id="1643" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="1645" href="UTxOErr.Ledger.html#596" class="Generalizable">s₂</a> <a id="1648" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="1650" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="1655" href="UTxOErr.SL.html#1629" class="Bound">s₂′</a>
  <a id="1661" href="Prelude.InferenceRules.html#56072" class="Function Operator">∙</a> <a id="1663" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟨</a> <a id="1665" href="UTxOErr.Ledger.html#585" class="Generalizable">s₁</a> <a id="1668" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⊎</a> <a id="1670" href="UTxOErr.Ledger.html#596" class="Generalizable">s₂</a> <a id="1673" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟩≡</a> <a id="1676" href="UTxOErr.Ledger.html#577" class="Generalizable">s</a>
    <a id="1682" href="Prelude.InferenceRules.html#13760" class="Function Operator">────────────────────────────────</a>
    <a id="1719" href="UTxOErr.HoareLogic.html#1196" class="Function">lift↑</a> <a id="1725" class="Symbol">(</a><a id="1726" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟨</a> <a id="1728" href="UTxOErr.Ledger.html#585" class="Generalizable">s₁</a> <a id="1731" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⊎</a> <a id="1733" href="UTxOErr.SL.html#1629" class="Bound">s₂′</a> <a id="1737" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟩≡_</a><a id="1740" class="Symbol">)</a> <a id="1742" class="Symbol">(</a><a id="1743" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="1745" href="UTxOErr.Ledger.html#638" class="Generalizable">t</a> <a id="1747" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="1749" href="UTxOErr.Ledger.html#577" class="Generalizable">s</a><a id="1750" class="Symbol">)</a>
<a id="1752" href="UTxOErr.SL.html#1618" class="Function">⊎-⟦⟧ᵗ˘</a> <a id="1759" class="Symbol">{</a><a id="1760" href="UTxOErr.SL.html#1760" class="Bound">t</a><a id="1761" class="Symbol">}{</a><a id="1763" href="UTxOErr.SL.html#1763" class="Bound">s₂</a><a id="1765" class="Symbol">}{</a><a id="1767" href="UTxOErr.SL.html#1767" class="Bound">s₁</a><a id="1769" class="Symbol">}{</a><a id="1771" href="UTxOErr.SL.html#1771" class="Bound">s</a><a id="1772" class="Symbol">}</a> <a id="1774" href="UTxOErr.SL.html#1774" class="Bound">s₂′</a> <a id="1778" href="UTxOErr.SL.html#1778" class="Bound">⟦t⟧s≡</a> <a id="1784" href="UTxOErr.SL.html#1784" class="Bound">≡s</a>
  <a id="1789" class="Keyword">with</a> <a id="1794" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="1796" href="UTxOErr.SL.html#1760" class="Bound">t</a> <a id="1798" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="1800" href="UTxOErr.SL.html#1771" class="Bound">s</a> <a id="1802" class="Symbol">|</a> <a id="1804" href="UTxOErr.SL.html#653" class="Function">⊎-⟦⟧ᵗ</a> <a id="1810" class="Symbol">{</a><a id="1811" class="Argument">t</a> <a id="1813" class="Symbol">=</a> <a id="1815" href="UTxOErr.SL.html#1760" class="Bound">t</a><a id="1816" class="Symbol">}{</a><a id="1818" href="UTxOErr.SL.html#1763" class="Bound">s₂</a><a id="1820" class="Symbol">}{</a><a id="1822" href="UTxOErr.SL.html#1767" class="Bound">s₁</a><a id="1824" class="Symbol">}</a> <a id="1826" href="UTxOErr.SL.html#1774" class="Bound">s₂′</a> <a id="1830" href="UTxOErr.SL.html#1778" class="Bound">⟦t⟧s≡</a> <a id="1836" class="Symbol">(</a><a id="1837" href="UTxOErr.HoareProperties.html#503" class="Postulate">⊎≡-comm</a> <a id="1845" class="Symbol">{</a><a id="1846" class="Argument">x</a> <a id="1848" class="Symbol">=</a> <a id="1850" href="UTxOErr.SL.html#1767" class="Bound">s₁</a><a id="1852" class="Symbol">}{</a><a id="1854" href="UTxOErr.SL.html#1763" class="Bound">s₂</a><a id="1856" class="Symbol">}</a> <a id="1858" href="UTxOErr.SL.html#1784" class="Bound">≡s</a><a id="1860" class="Symbol">)</a>
<a id="1862" class="Symbol">...</a> <a id="1866" class="Symbol">|</a> <a id="1868" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="1873" class="Symbol">_</a> <a id="1875" class="Symbol">|</a> <a id="1877" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="1882" href="UTxOErr.SL.html#1882" class="Bound">≡s′</a> <a id="1886" class="Symbol">=</a> <a id="1888" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="1893" class="Symbol">(</a><a id="1894" href="UTxOErr.HoareProperties.html#503" class="Postulate">⊎≡-comm</a> <a id="1902" class="Symbol">{</a><a id="1903" class="Argument">x</a> <a id="1905" class="Symbol">=</a> <a id="1907" class="Bound">s₂′</a><a id="1910" class="Symbol">}{</a><a id="1912" class="Bound">s₁</a><a id="1914" class="Symbol">}</a> <a id="1916" href="UTxOErr.SL.html#1882" class="Bound">≡s′</a><a id="1919" class="Symbol">)</a>

<a id="⊎-⟦⟧"></a><a id="1922" href="UTxOErr.SL.html#1922" class="Function">⊎-⟦⟧</a> <a id="1927" class="Symbol">:</a> <a id="1929" class="Symbol">∀</a> <a id="1931" href="UTxOErr.SL.html#1931" class="Bound">s₁′</a> <a id="1935" class="Symbol">→</a>
  <a id="1939" href="Prelude.InferenceRules.html#56141" class="Function Operator">∙</a> <a id="1941" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="1943" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="1945" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="1947" href="UTxOErr.Ledger.html#585" class="Generalizable">s₁</a> <a id="1950" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="1952" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="1957" href="UTxOErr.SL.html#1931" class="Bound">s₁′</a>
  <a id="1963" href="Prelude.InferenceRules.html#56072" class="Function Operator">∙</a> <a id="1965" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟨</a> <a id="1967" href="UTxOErr.Ledger.html#585" class="Generalizable">s₁</a> <a id="1970" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⊎</a> <a id="1972" href="UTxOErr.Ledger.html#596" class="Generalizable">s₂</a> <a id="1975" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟩≡</a> <a id="1978" href="UTxOErr.Ledger.html#577" class="Generalizable">s</a>
    <a id="1984" href="Prelude.InferenceRules.html#13760" class="Function Operator">────────────────────────────────</a>
    <a id="2021" href="UTxOErr.HoareLogic.html#1196" class="Function">lift↑</a> <a id="2027" class="Symbol">(</a><a id="2028" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟨</a> <a id="2030" href="UTxOErr.SL.html#1931" class="Bound">s₁′</a> <a id="2034" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⊎</a> <a id="2036" href="UTxOErr.Ledger.html#596" class="Generalizable">s₂</a> <a id="2039" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟩≡_</a><a id="2042" class="Symbol">)</a> <a id="2044" class="Symbol">(</a><a id="2045" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="2047" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="2049" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="2051" href="UTxOErr.Ledger.html#577" class="Generalizable">s</a><a id="2052" class="Symbol">)</a>
<a id="2054" href="UTxOErr.SL.html#1922" class="Function">⊎-⟦⟧</a> <a id="2059" class="Symbol">{</a><a id="2060" class="Argument">l</a> <a id="2062" class="Symbol">=</a> <a id="2064" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="2066" class="Symbol">}</a> <a id="2068" class="Symbol">_</a> <a id="2070" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a> <a id="2075" href="UTxOErr.SL.html#2075" class="Bound">p</a> <a id="2077" class="Symbol">=</a> <a id="2079" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="2084" href="UTxOErr.SL.html#2075" class="Bound">p</a>
<a id="2086" href="UTxOErr.SL.html#1922" class="Function">⊎-⟦⟧</a> <a id="2091" class="Symbol">{</a><a id="2092" class="Argument">l</a> <a id="2094" class="Symbol">=</a> <a id="2096" href="UTxOErr.SL.html#2096" class="Bound">t</a> <a id="2098" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="2100" href="UTxOErr.SL.html#2100" class="Bound">l</a><a id="2101" class="Symbol">}</a> <a id="2103" class="Symbol">{</a><a id="2104" class="Argument">s₁</a> <a id="2107" class="Symbol">=</a> <a id="2109" href="UTxOErr.SL.html#2109" class="Bound">s₁</a><a id="2111" class="Symbol">}</a> <a id="2113" class="Symbol">{</a><a id="2114" href="UTxOErr.SL.html#2114" class="Bound">s₂</a><a id="2116" class="Symbol">}</a> <a id="2118" class="Symbol">{</a><a id="2119" href="UTxOErr.SL.html#2119" class="Bound">s</a><a id="2120" class="Symbol">}</a> <a id="2122" href="UTxOErr.SL.html#2122" class="Bound">s₁″</a> <a id="2126" href="UTxOErr.SL.html#2126" class="Bound">eq</a> <a id="2129" href="UTxOErr.SL.html#2129" class="Bound">≡s</a>
  <a id="2134" class="Keyword">with</a> <a id="2139" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="2141" href="UTxOErr.SL.html#2096" class="Bound">t</a> <a id="2143" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="2145" href="UTxOErr.SL.html#2109" class="Bound">s₁</a> <a id="2148" class="Keyword">in</a> <a id="2151" class="Argument">⟦t⟧s≡</a>
<a id="2157" class="Symbol">...</a> <a id="2161" class="Symbol">|</a> <a id="2163" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2168" href="UTxOErr.SL.html#2168" class="Bound">s₁′</a>
  <a id="2174" class="Keyword">with</a> <a id="2179" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="2181" class="Bound">t</a> <a id="2183" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="2185" class="Bound">s</a> <a id="2187" class="Symbol">|</a> <a id="2189" href="UTxOErr.SL.html#653" class="Function">⊎-⟦⟧ᵗ</a> <a id="2195" class="Symbol">{</a><a id="2196" class="Argument">t</a> <a id="2198" class="Symbol">=</a> <a id="2200" class="Bound">t</a><a id="2201" class="Symbol">}</a> <a id="2203" class="Symbol">{</a><a id="2204" class="Argument">s₁</a> <a id="2207" class="Symbol">=</a> <a id="2209" class="Bound">s₁</a><a id="2211" class="Symbol">}</a> <a id="2213" class="Symbol">{</a><a id="2214" class="Argument">s₂</a> <a id="2217" class="Symbol">=</a> <a id="2219" class="Bound">s₂</a><a id="2221" class="Symbol">}</a> <a id="2223" href="UTxOErr.SL.html#2168" class="Bound">s₁′</a> <a id="2227" href="UTxOErr.SL.html#2151" class="Bound">⟦t⟧s≡</a> <a id="2233" class="Bound">≡s</a>
<a id="2236" class="Symbol">...</a> <a id="2240" class="Symbol">|</a> <a id="2242" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2247" href="UTxOErr.SL.html#2247" class="Bound">s′</a>  <a id="2251" class="Symbol">|</a> <a id="2253" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="2258" href="UTxOErr.SL.html#2258" class="Bound">s₁′⊎s₂≡s′</a>
  <a id="2270" class="Keyword">with</a> <a id="2275" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="2277" class="Bound">l</a> <a id="2279" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="2281" class="Bound">s₁′</a> <a id="2285" class="Keyword">in</a> <a id="2288" class="Argument">⟦l⟧s≡</a> <a id="2294" class="Symbol">|</a> <a id="2296" class="Bound">eq</a>
<a id="2299" class="Symbol">...</a> <a id="2303" class="Symbol">|</a> <a id="2305" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2310" class="DottedPattern Symbol">.</a><a id="2311" class="DottedPattern Bound">s₁″</a>           <a id="2325" class="Symbol">|</a> <a id="2327" href="Agda.Builtin.Equality.html#190" class="InductiveConstructor">refl</a>
  <a id="2334" class="Symbol">=</a> <a id="2336" href="UTxOErr.SL.html#1922" class="Function">⊎-⟦⟧</a> <a id="2341" class="Symbol">{</a><a id="2342" class="Argument">l</a> <a id="2344" class="Symbol">=</a> <a id="2346" class="Bound">l</a><a id="2347" class="Symbol">}</a> <a id="2349" class="Symbol">{</a><a id="2350" class="Argument">s₁</a> <a id="2353" class="Symbol">=</a> <a id="2355" class="Bound">s₁′</a><a id="2358" class="Symbol">}</a> <a id="2360" class="Symbol">{</a><a id="2361" class="Argument">s₂</a> <a id="2364" class="Symbol">=</a> <a id="2366" class="Bound">s₂</a><a id="2368" class="Symbol">}</a> <a id="2370" class="Bound">s₁″</a> <a id="2374" href="UTxOErr.SL.html#2288" class="Bound">⟦l⟧s≡</a> <a id="2380" class="Bound">s₁′⊎s₂≡s′</a>

<a id="⊎-⟦⟧˘"></a><a id="2391" href="UTxOErr.SL.html#2391" class="Function">⊎-⟦⟧˘</a> <a id="2397" class="Symbol">:</a> <a id="2399" class="Symbol">∀</a> <a id="2401" href="UTxOErr.SL.html#2401" class="Bound">s₂′</a> <a id="2405" class="Symbol">→</a>
  <a id="2409" href="Prelude.InferenceRules.html#56141" class="Function Operator">∙</a> <a id="2411" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="2413" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="2415" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="2417" href="UTxOErr.Ledger.html#596" class="Generalizable">s₂</a> <a id="2420" href="Agda.Builtin.Equality.html#133" class="Datatype Operator">≡</a> <a id="2422" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2427" href="UTxOErr.SL.html#2401" class="Bound">s₂′</a>
  <a id="2433" href="Prelude.InferenceRules.html#56072" class="Function Operator">∙</a> <a id="2435" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟨</a> <a id="2437" href="UTxOErr.Ledger.html#585" class="Generalizable">s₁</a> <a id="2440" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⊎</a> <a id="2442" href="UTxOErr.Ledger.html#596" class="Generalizable">s₂</a> <a id="2445" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟩≡</a> <a id="2448" href="UTxOErr.Ledger.html#577" class="Generalizable">s</a>
    <a id="2454" href="Prelude.InferenceRules.html#13760" class="Function Operator">────────────────────────────────</a>
    <a id="2491" href="UTxOErr.HoareLogic.html#1196" class="Function">lift↑</a> <a id="2497" class="Symbol">(</a><a id="2498" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟨</a> <a id="2500" href="UTxOErr.Ledger.html#585" class="Generalizable">s₁</a> <a id="2503" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⊎</a> <a id="2505" href="UTxOErr.SL.html#2401" class="Bound">s₂′</a> <a id="2509" href="Prelude.Maps.AsSets.html#4463" class="Function Operator">⟩≡_</a><a id="2512" class="Symbol">)</a> <a id="2514" class="Symbol">(</a><a id="2515" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="2517" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="2519" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="2521" href="UTxOErr.Ledger.html#577" class="Generalizable">s</a><a id="2522" class="Symbol">)</a>
<a id="2524" href="UTxOErr.SL.html#2391" class="Function">⊎-⟦⟧˘</a> <a id="2530" class="Symbol">{</a><a id="2531" class="Argument">l</a> <a id="2533" class="Symbol">=</a> <a id="2535" href="UTxOErr.SL.html#2535" class="Bound">l</a><a id="2536" class="Symbol">}</a> <a id="2538" class="Symbol">{</a><a id="2539" class="Argument">s₂</a> <a id="2542" class="Symbol">=</a> <a id="2544" href="UTxOErr.SL.html#2544" class="Bound">s₂</a><a id="2546" class="Symbol">}</a> <a id="2548" class="Symbol">{</a><a id="2549" href="UTxOErr.SL.html#2549" class="Bound">s₁</a><a id="2551" class="Symbol">}</a> <a id="2553" class="Symbol">{</a><a id="2554" href="UTxOErr.SL.html#2554" class="Bound">s</a><a id="2555" class="Symbol">}</a> <a id="2557" href="UTxOErr.SL.html#2557" class="Bound">s₂′</a> <a id="2561" href="UTxOErr.SL.html#2561" class="Bound">eq</a> <a id="2564" href="UTxOErr.SL.html#2564" class="Bound">≡s</a>
  <a id="2569" class="Keyword">with</a> <a id="2574" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="2576" href="UTxOErr.SL.html#2535" class="Bound">l</a> <a id="2578" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="2580" href="UTxOErr.SL.html#2554" class="Bound">s</a> <a id="2582" class="Symbol">|</a> <a id="2584" href="UTxOErr.SL.html#1922" class="Function">⊎-⟦⟧</a> <a id="2589" class="Symbol">{</a><a id="2590" class="Argument">l</a> <a id="2592" class="Symbol">=</a> <a id="2594" href="UTxOErr.SL.html#2535" class="Bound">l</a><a id="2595" class="Symbol">}</a> <a id="2597" class="Symbol">{</a><a id="2598" class="Argument">s₁</a> <a id="2601" class="Symbol">=</a> <a id="2603" href="UTxOErr.SL.html#2544" class="Bound">s₂</a><a id="2605" class="Symbol">}</a> <a id="2607" class="Symbol">{</a><a id="2608" href="UTxOErr.SL.html#2549" class="Bound">s₁</a><a id="2610" class="Symbol">}</a> <a id="2612" class="Symbol">{</a><a id="2613" href="UTxOErr.SL.html#2554" class="Bound">s</a><a id="2614" class="Symbol">}</a> <a id="2616" href="UTxOErr.SL.html#2557" class="Bound">s₂′</a> <a id="2620" href="UTxOErr.SL.html#2561" class="Bound">eq</a> <a id="2623" class="Symbol">(</a><a id="2624" href="UTxOErr.HoareProperties.html#503" class="Postulate">⊎≡-comm</a> <a id="2632" class="Symbol">{</a><a id="2633" class="Argument">x</a> <a id="2635" class="Symbol">=</a> <a id="2637" href="UTxOErr.SL.html#2549" class="Bound">s₁</a><a id="2639" class="Symbol">}{</a><a id="2641" href="UTxOErr.SL.html#2544" class="Bound">s₂</a><a id="2643" class="Symbol">}</a> <a id="2645" href="UTxOErr.SL.html#2564" class="Bound">≡s</a><a id="2647" class="Symbol">)</a>
<a id="2649" class="Symbol">...</a> <a id="2653" class="Symbol">|</a> <a id="2655" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2660" class="Symbol">_</a> <a id="2662" class="Symbol">|</a> <a id="2664" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="2669" href="UTxOErr.SL.html#2669" class="Bound">≡s′</a> <a id="2673" class="Symbol">=</a> <a id="2675" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="2680" class="Symbol">(</a><a id="2681" href="UTxOErr.HoareProperties.html#503" class="Postulate">⊎≡-comm</a> <a id="2689" class="Symbol">{</a><a id="2690" class="Argument">x</a> <a id="2692" class="Symbol">=</a> <a id="2694" class="Bound">s₂′</a><a id="2697" class="Symbol">}{</a><a id="2699" class="Bound">s₁</a><a id="2701" class="Symbol">}</a> <a id="2703" href="UTxOErr.SL.html#2669" class="Bound">≡s′</a><a id="2706" class="Symbol">)</a>


<a id="_-supports-_"></a><a id="2710" href="UTxOErr.SL.html#2710" class="Function Operator">_-supports-_</a> <a id="2723" class="Symbol">:</a> <a id="2725" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="2730" href="UTxOErr.UTxO.html#682" class="Record">TxOutputRef</a> <a id="2742" class="Symbol">→</a> <a id="2744" href="UTxOErr.HoareLogic.html#702" class="Function">Assertion</a> <a id="2754" class="Symbol">→</a> <a id="2756" href="Agda.Primitive.html#320" class="Primitive">Type</a>
<a id="2761" href="UTxOErr.SL.html#2761" class="Bound">sup</a> <a id="2765" href="UTxOErr.SL.html#2710" class="Function Operator">-supports-</a> <a id="2776" href="UTxOErr.SL.html#2776" class="Bound">P</a> <a id="2778" class="Symbol">=</a> <a id="2780" class="Symbol">∀</a> <a id="2782" class="Symbol">(</a><a id="2783" href="UTxOErr.SL.html#2783" class="Bound">s</a> <a id="2785" class="Symbol">:</a> <a id="2787" href="UTxOErr.UTxO.html#992" class="Function">S</a><a id="2788" class="Symbol">)</a> <a id="2790" class="Symbol">→</a> <a id="2792" href="UTxOErr.SL.html#2776" class="Bound">P</a> <a id="2794" href="UTxOErr.SL.html#2783" class="Bound">s</a> <a id="2796" href="Prelude.General.html#484" class="Function Operator">↔</a> <a id="2798" href="UTxOErr.SL.html#2776" class="Bound">P</a> <a id="2800" class="Symbol">(</a><a id="2801" href="Prelude.Maps.AsSets.html#3369" class="Function">filterK</a> <a id="2809" class="Symbol">(</a><a id="2810" href="Prelude.Membership.html#455" class="Field Operator">_∈?</a> <a id="2814" href="UTxOErr.SL.html#2761" class="Bound">sup</a><a id="2817" class="Symbol">)</a> <a id="2819" href="UTxOErr.SL.html#2783" class="Bound">s</a><a id="2820" class="Symbol">)</a>

<a id="2823" class="Keyword">instance</a>
  <a id="2834" class="Comment">-- Apart-or : TxOutputRef // Assertion</a>
  <a id="2875" class="Comment">-- Apart-or ._♯_ or P = ¬ or -supports- P</a>
  <a id="2919" class="Comment">-- Apart-or ._♯_ or P = ∀ (s : S) → (P s ↔ P (s ─ [ or ]))</a>
  <a id="2980" class="Comment">--                                × (∀ (o : TxOutput) → P s ↔ P (s ∪ singleton (or , o)))</a>

  <a id="Apart-L"></a><a id="3073" href="UTxOErr.SL.html#3073" class="Function">Apart-L</a> <a id="3081" class="Symbol">:</a> <a id="3083" href="Common.html#1622" class="Function">L</a> <a id="3085" href="Prelude.Apartness.html#162" class="Record Operator">//</a> <a id="3088" href="UTxOErr.HoareLogic.html#702" class="Function">Assertion</a>
  <a id="3100" class="Comment">-- Apart-L ._♯_ l P = All (λ or → or ♯ P) (concatMap outputRefs l)</a>
  <a id="3169" href="UTxOErr.SL.html#3073" class="Function">Apart-L</a> <a id="3177" class="Symbol">.</a><a id="3178" href="Prelude.Apartness.html#255" class="Field Operator">_♯_</a> <a id="3182" href="UTxOErr.SL.html#3182" class="Bound">l</a> <a id="3184" href="UTxOErr.SL.html#3184" class="Bound">P</a> <a id="3186" class="Symbol">=</a> <a id="3188" class="Symbol">(</a><a id="3189" href="UTxOErr.SL.html#2710" class="Function Operator">_-supports-</a> <a id="3201" href="UTxOErr.SL.html#3184" class="Bound">P</a><a id="3202" class="Symbol">)</a> <a id="3204" href="Relation.Unary.html#1751" class="Function Operator">⊆¹</a> <a id="3207" class="Symbol">(</a><a id="3208" href="Data.List.Relation.Binary.Disjoint.Setoid.html#851" class="Function">Disjoint</a> <a id="3217" href="Function.Base.html#1928" class="Function Operator">$</a> <a id="3219" href="Data.List.Base.html#4459" class="Function">concatMap</a> <a id="3229" href="Common.html#2104" class="Function">outputRefs</a> <a id="3240" href="UTxOErr.SL.html#3182" class="Bound">l</a><a id="3241" class="Symbol">)</a>

<a id="3244" class="Comment">-- The proof of the frame rule from separation logic, allowing us to prove formulas in minimal contexts</a>
<a id="3348" class="Comment">-- and then weaken our results to the desired context.</a>
<a id="[FRAME]"></a><a id="3403" href="UTxOErr.SL.html#3403" class="Function">[FRAME]</a> <a id="3411" class="Symbol">:</a> <a id="3413" class="Symbol">∀</a> <a id="3415" href="UTxOErr.SL.html#3415" class="Bound">R</a> <a id="3417" class="Symbol">→</a>
  <a id="3421" href="Prelude.InferenceRules.html#56141" class="Function Operator">∙</a> <a id="3423" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="3425" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="3427" href="UTxOErr.SL.html#3415" class="Bound">R</a>
  <a id="3431" href="Prelude.InferenceRules.html#56072" class="Function Operator">∙</a> <a id="3433" href="UTxOErr.HoareLogic.html#1296" class="Function Operator">⟨</a> <a id="3435" href="UTxOErr.HoareLogic.html#732" class="Generalizable">P</a> <a id="3437" href="UTxOErr.HoareLogic.html#1296" class="Function Operator">⟩</a> <a id="3439" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="3441" href="UTxOErr.HoareLogic.html#1296" class="Function Operator">⟨</a> <a id="3443" href="UTxOErr.HoareLogic.html#743" class="Generalizable">Q</a> <a id="3445" href="UTxOErr.HoareLogic.html#1296" class="Function Operator">⟩</a>
    <a id="3451" href="Prelude.InferenceRules.html#14112" class="Function Operator">─────────────────────</a>
    <a id="3477" href="UTxOErr.HoareLogic.html#1296" class="Function Operator">⟨</a> <a id="3479" href="UTxOErr.HoareLogic.html#732" class="Generalizable">P</a> <a id="3481" href="UTxOErr.HoareLogic.html#840" class="Function Operator">∗</a> <a id="3483" href="UTxOErr.SL.html#3415" class="Bound">R</a> <a id="3485" href="UTxOErr.HoareLogic.html#1296" class="Function Operator">⟩</a> <a id="3487" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="3489" href="UTxOErr.HoareLogic.html#1296" class="Function Operator">⟨</a> <a id="3491" href="UTxOErr.HoareLogic.html#743" class="Generalizable">Q</a> <a id="3493" href="UTxOErr.HoareLogic.html#840" class="Function Operator">∗</a> <a id="3495" href="UTxOErr.SL.html#3415" class="Bound">R</a> <a id="3497" href="UTxOErr.HoareLogic.html#1296" class="Function Operator">⟩</a>

<a id="3500" class="Comment">{- Not provable without freshness side-conditions (i.e. l ♯ R).

Counter-example:

✓ ⟨ t₀₀ ↦ 1 at A ⟩
  t₁
  ⟨ t₁₀ ↦ 1 at B ⟩

¬ ⟨ t₀₀ ↦ 1 at A ∗ t₁₀ ↦ 2 at A ⟩
  t₁
  ⟨ t₁₀ ↦ 1 at B ∗ t₁₀ ↦ 2 at A ⟩

Alternatives:
  ∙ Allow key repetitions (e.g. `t₁₀`) and argue about a sensible genesis configuration.
  ∙ ⋯
-}</a>

<a id="3814" href="UTxOErr.SL.html#3403" class="Function">[FRAME]</a> <a id="3822" class="Symbol">{</a><a id="3823" href="UTxOErr.SL.html#3823" class="Bound">l</a><a id="3824" class="Symbol">}{</a><a id="3826" href="UTxOErr.SL.html#3826" class="Bound">P</a><a id="3827" class="Symbol">}{</a><a id="3829" href="UTxOErr.SL.html#3829" class="Bound">Q</a><a id="3830" class="Symbol">}</a> <a id="3832" href="UTxOErr.SL.html#3832" class="Bound">R</a> <a id="3834" href="UTxOErr.SL.html#3834" class="Bound">l♯R</a> <a id="3838" href="UTxOErr.SL.html#3838" class="Bound">PlQ</a> <a id="3842" class="Symbol">{</a><a id="3843" href="UTxOErr.SL.html#3843" class="Bound">s</a><a id="3844" class="Symbol">}</a> <a id="3846" class="Symbol">(</a><a id="3847" href="UTxOErr.SL.html#3847" class="Bound">s₁</a> <a id="3850" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="3852" href="UTxOErr.SL.html#3852" class="Bound">s₂</a> <a id="3855" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="3857" href="UTxOErr.SL.html#3857" class="Bound">≡s</a> <a id="3860" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="3862" href="UTxOErr.SL.html#3862" class="Bound">Ps₁</a> <a id="3866" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="3868" href="UTxOErr.SL.html#3868" class="Bound">Rs₂</a><a id="3871" class="Symbol">)</a>
  <a id="3875" class="Keyword">with</a> <a id="3880" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="3882" href="UTxOErr.SL.html#3823" class="Bound">l</a> <a id="3884" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="3886" href="UTxOErr.SL.html#3847" class="Bound">s₁</a> <a id="3889" class="Keyword">in</a> <a id="3892" class="Argument">s₁≡</a> <a id="3896" class="Symbol">|</a> <a id="3898" href="UTxOErr.SL.html#3838" class="Bound">PlQ</a> <a id="3902" href="UTxOErr.SL.html#3862" class="Bound">Ps₁</a>
<a id="3906" class="Symbol">...</a> <a id="3910" class="Symbol">|</a> <a id="3912" class="Symbol">.</a><a id="3913" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="3918" href="UTxOErr.SL.html#3918" class="Bound">s₁′</a> <a id="3922" class="Symbol">|</a> <a id="3924" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="3929" href="UTxOErr.SL.html#3929" class="Bound">Qs₁′</a>
  <a id="3936" class="Keyword">with</a> <a id="3941" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟦</a> <a id="3943" class="Bound">l</a> <a id="3945" href="UTxOErr.Ledger.html#1027" class="Field Operator">⟧</a> <a id="3947" class="Bound">s</a> <a id="3949" class="Keyword">in</a> <a id="3952" class="Argument">s≡</a> <a id="3955" class="Symbol">|</a> <a id="3957" href="UTxOErr.SL.html#1922" class="Function">⊎-⟦⟧</a> <a id="3962" class="Symbol">{</a><a id="3963" class="Argument">l</a> <a id="3965" class="Symbol">=</a> <a id="3967" class="Bound">l</a><a id="3968" class="Symbol">}</a> <a id="3970" class="Symbol">{</a><a id="3971" class="Argument">s₁</a> <a id="3974" class="Symbol">=</a> <a id="3976" class="Bound">s₁</a><a id="3978" class="Symbol">}</a> <a id="3980" class="Symbol">{</a><a id="3981" class="Argument">s₂</a> <a id="3984" class="Symbol">=</a> <a id="3986" class="Bound">s₂</a><a id="3988" class="Symbol">}</a> <a id="3990" href="UTxOErr.SL.html#3918" class="Bound">s₁′</a> <a id="3994" href="UTxOErr.SL.html#3892" class="Bound">s₁≡</a> <a id="3998" class="Bound">≡s</a>
<a id="4001" class="Symbol">...</a> <a id="4005" class="Symbol">|</a> <a id="4007" class="Symbol">.</a><a id="4008" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="4013" href="UTxOErr.SL.html#4013" class="Bound">s′</a> <a id="4016" class="Symbol">|</a> <a id="4018" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="4023" href="UTxOErr.SL.html#4023" class="Bound">≡s′</a>
    <a id="4031" class="Symbol">=</a> <a id="4033" href="UTxOErr.HoareLogic.html#1220" class="InductiveConstructor">ret↑</a> <a id="4038" class="Symbol">(</a><a id="4039" class="Bound">s₁′</a> <a id="4043" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4045" class="Bound">s₂</a> <a id="4048" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4050" href="UTxOErr.SL.html#4023" class="Bound">≡s′</a> <a id="4054" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4056" class="Bound">Qs₁′</a> <a id="4061" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="4063" class="Bound">Rs₂</a><a id="4066" class="Symbol">)</a>

<a id="4069" class="Keyword">open</a> <a id="4074" href="UTxOErr.HoareLogic.html#3381" class="Module">HoareReasoning</a>
<a id="ℝ[FRAME]"></a><a id="4089" href="UTxOErr.SL.html#4089" class="Function">ℝ[FRAME]</a> <a id="4098" class="Symbol">:</a> <a id="4100" class="Symbol">∀</a> <a id="4102" href="UTxOErr.SL.html#4102" class="Bound">R</a> <a id="4104" class="Symbol">→</a>
  <a id="4108" href="Prelude.InferenceRules.html#56141" class="Function Operator">∙</a> <a id="4110" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="4112" href="Prelude.Apartness.html#255" class="Field Operator">♯</a> <a id="4114" href="UTxOErr.SL.html#4102" class="Bound">R</a>
  <a id="4118" href="Prelude.InferenceRules.html#56072" class="Function Operator">∙</a> <a id="4120" href="UTxOErr.HoareLogic.html#3463" class="Record Operator">ℝ⟨</a> <a id="4123" href="UTxOErr.HoareLogic.html#732" class="Generalizable">P</a> <a id="4125" href="UTxOErr.HoareLogic.html#3463" class="Record Operator">⟩</a> <a id="4127" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="4129" href="UTxOErr.HoareLogic.html#3463" class="Record Operator">⟨</a> <a id="4131" href="UTxOErr.HoareLogic.html#743" class="Generalizable">Q</a> <a id="4133" href="UTxOErr.HoareLogic.html#3463" class="Record Operator">⟩</a>
    <a id="4139" href="Prelude.InferenceRules.html#14112" class="Function Operator">─────────────────────</a>
    <a id="4165" href="UTxOErr.HoareLogic.html#3463" class="Record Operator">ℝ⟨</a> <a id="4168" href="UTxOErr.HoareLogic.html#732" class="Generalizable">P</a> <a id="4170" href="UTxOErr.HoareLogic.html#840" class="Function Operator">∗</a> <a id="4172" href="UTxOErr.SL.html#4102" class="Bound">R</a> <a id="4174" href="UTxOErr.HoareLogic.html#3463" class="Record Operator">⟩</a> <a id="4176" href="UTxOErr.Ledger.html#653" class="Generalizable">l</a> <a id="4178" href="UTxOErr.HoareLogic.html#3463" class="Record Operator">⟨</a> <a id="4180" href="UTxOErr.HoareLogic.html#743" class="Generalizable">Q</a> <a id="4182" href="UTxOErr.HoareLogic.html#840" class="Function Operator">∗</a> <a id="4184" href="UTxOErr.SL.html#4102" class="Bound">R</a> <a id="4186" href="UTxOErr.HoareLogic.html#3463" class="Record Operator">⟩</a>
<a id="4188" href="UTxOErr.SL.html#4089" class="Function">ℝ[FRAME]</a> <a id="4197" class="Symbol">{</a><a id="4198" class="Argument">l</a> <a id="4200" class="Symbol">=</a> <a id="4202" href="UTxOErr.SL.html#4202" class="Bound">l</a><a id="4203" class="Symbol">}</a> <a id="4205" href="UTxOErr.SL.html#4205" class="Bound">R</a> <a id="4207" href="UTxOErr.SL.html#4207" class="Bound">l♯R</a> <a id="4211" href="UTxOErr.SL.html#4211" class="Bound">PlQ</a> <a id="4215" class="Symbol">=</a> <a id="4217" href="UTxOErr.HoareLogic.html#3541" class="InductiveConstructor Operator">mkℝ</a> <a id="4221" href="UTxOErr.SL.html#3403" class="Function">[FRAME]</a> <a id="4229" class="Symbol">{</a><a id="4230" class="Argument">l</a> <a id="4232" class="Symbol">=</a> <a id="4234" href="UTxOErr.SL.html#4202" class="Bound">l</a><a id="4235" class="Symbol">}</a> <a id="4237" href="UTxOErr.SL.html#4205" class="Bound">R</a> <a id="4239" href="UTxOErr.SL.html#4207" class="Bound">l♯R</a> <a id="4243" class="Symbol">(</a><a id="4244" href="UTxOErr.HoareLogic.html#3556" class="Field Operator">begin</a> <a id="4250" href="UTxOErr.SL.html#4211" class="Bound">PlQ</a><a id="4253" class="Symbol">)</a>
</pre></body></html>