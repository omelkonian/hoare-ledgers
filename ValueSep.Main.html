<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>ValueSep.Main</title><link rel="stylesheet" href="css/Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="ValueSep.Main.html" class="Module">ValueSep.Main</a> <a id="22" class="Keyword">where</a>

<a id="29" class="Comment">-- ** Concrete implementation of (shallow) maps (mostly copied from Prelude.Maps).</a>
<a id="112" class="Comment">--    ∙ this makes the code more self-contained</a>
<a id="160" class="Comment">--    ∙ as the implementation is not abstract anymore, we can utilize decidability in our (closed) examples</a>
<a id="268" class="Keyword">open</a> <a id="273" class="Keyword">import</a> <a id="280" href="ValueSep.Maps.html" class="Module">ValueSep.Maps</a>

<a id="295" class="Comment">-- ** A simple definition of a bank ledger as a series of transactions: A —→⟨ v ⟩ B.</a>
<a id="380" class="Comment">-- We model the ledger state as maps from participants to balances, using a concrete map implementation in ValueSep.Maps,</a>
<a id="502" class="Comment">-- and define both operational and denotational semantics.</a>
<a id="561" class="Comment">-- [Proofs]</a>
<a id="573" class="Comment">--    * correspondence between operational and denotational semantics</a>
<a id="643" class="Comment">--    * useful lemmas about the ledger-specific operation `transfer/[_∣_↦_]`</a>
<a id="720" class="Keyword">open</a> <a id="725" class="Keyword">import</a> <a id="732" href="ValueSep.Ledger.html" class="Module">ValueSep.Ledger</a>

<a id="749" class="Comment">-- ** A Hoare-style axiomatic semantics, based on a deep embedding of propositions.</a>
<a id="833" class="Comment">-- We also provide some utilities for working with Hoare triples and convenient reasoning syntax.</a>
<a id="931" class="Comment">-- [Proofs]</a>
<a id="943" class="Comment">--   * correspondence with denotational semantics and, by transitivity, operational semantics.</a>
<a id="1038" class="Comment">--   * associativity/commutativity of separating conjuction _∗_</a>
<a id="1102" class="Keyword">open</a> <a id="1107" class="Keyword">import</a> <a id="1114" href="ValueSep.SimpleHoareLogic.html" class="Module">ValueSep.SimpleHoareLogic</a>
<a id="1140" class="Keyword">open</a> <a id="1145" class="Keyword">import</a> <a id="1152" href="ValueSep.StrongHoareLogic.html" class="Module">ValueSep.StrongHoareLogic</a>
<a id="1178" class="Keyword">open</a> <a id="1183" class="Keyword">import</a> <a id="1190" href="ValueSep.WeakHoareLogic.html" class="Module">ValueSep.WeakHoareLogic</a>
<a id="1214" class="Keyword">open</a> <a id="1219" class="Keyword">import</a> <a id="1226" href="ValueSep.HoareProperties.html" class="Module">ValueSep.HoareProperties</a>

<a id="1252" class="Comment">-- ** Introduce the concept of disjointness for propositions, i.e. when the participants they refer to do not overlap,</a>
<a id="1371" class="Comment">-- which allows us to express the frame rule of Separation Logic (SL).</a>
<a id="1442" class="Comment">-- [Proofs]</a>
<a id="1454" class="Comment">--  * useful lemmas about separation, transferring values, etc...</a>
<a id="1520" class="Comment">--  * the [FRAME] inference rule, which allows us to reason about a sub-formula and then inject the result in a larger context</a>
<a id="1647" class="Comment">-- open import ValueSep.SimpleSL</a>
<a id="1680" class="Keyword">open</a> <a id="1685" class="Keyword">import</a> <a id="1692" href="ValueSep.StrongSL.html" class="Module">ValueSep.StrongSL</a>

<a id="1711" class="Comment">-- **ISSUE** How do we formulate frame, seems incompatible with the semantics of a transaction that fails.</a>
<a id="1818" class="Comment">-- **SOLUTION** Change domain to incorporate failure, i.e. `S -&gt; S` to `S -&gt; Maybe S`.</a>

<a id="1906" class="Comment">-- ** Define interleaving of two ledgers and prove the parallel rule of Concurrent Separation Logic (CSL).</a>
<a id="2013" class="Comment">-- [Proofs]</a>
<a id="2025" class="Comment">--  * the [PAR] inference rule, which utilizes [FRAME] to let us reason about disjoint ledgers independently/concurrently,</a>
<a id="2148" class="Comment">-- and then compose the proofs (given that the pre-/post-conditions are sufficiently disjoint)</a>
<a id="2243" class="Comment">-- to conclude something of a larger ledgers, namely any ledger that is an interleaving of the first two.</a>
<a id="2349" class="Keyword">open</a> <a id="2354" class="Keyword">import</a> <a id="2361" href="ValueSep.StrongCSL.html" class="Module">ValueSep.StrongCSL</a>

<a id="2381" class="Comment">-- ** An example of a ledger consisting of 4 transactions t₁⋯t₄,</a>
<a id="2446" class="Comment">--    recording that values are correctly updated in pre-/post-conditions.</a>
<a id="2521" class="Comment">-- 1. the first proof h repeatively uses the [FRAME] rule,</a>
<a id="2580" class="Comment">--    but it quickly gets tedious because we need to reason about the whole ledger (all 4 transactions),</a>
<a id="2685" class="Comment">--    although t₁ and t₃ act on a completely different set of participants than t₂ and t₄.</a>
<a id="2776" class="Comment">-- 2. the second proof h′ utilizes modular reasoning via [PAR];</a>
<a id="2840" class="Comment">--    we only prove smaller/simpler proofs for t₁/t₃ and t₂/t₄ and then compose them.</a>
<a id="2926" class="Keyword">open</a> <a id="2931" class="Keyword">import</a> <a id="2938" href="ValueSep.StrongExample.html" class="Module">ValueSep.StrongExample</a>
</pre></body></html>